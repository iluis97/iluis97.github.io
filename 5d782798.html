<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>SpringBoot 知识梳理 | LuisのBlog</title><meta name="author" content="Luis"><meta name="copyright" content="Luis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="IOC 控制反转将bean的创建交给spring处理，无需关心创建细节。Spring IoC（控制反转）容器是其框架的核心，负责管理应用对象的生命周期和依赖关系。 IoC 的实现方式：依赖注入（DI）   方式 示例 特点    构造函数注入 @Autowired on constructor 适用于强依赖、不可为空的场景   Setter 注入 @Autowired on setter 适用于可"><meta property="og:type" content="article"><meta property="og:title" content="SpringBoot 知识梳理"><meta property="og:url" content="https://iluis.cn/5d782798.html"><meta property="og:site_name" content="LuisのBlog"><meta property="og:description" content="IOC 控制反转将bean的创建交给spring处理，无需关心创建细节。Spring IoC（控制反转）容器是其框架的核心，负责管理应用对象的生命周期和依赖关系。 IoC 的实现方式：依赖注入（DI）   方式 示例 特点    构造函数注入 @Autowired on constructor 适用于强依赖、不可为空的场景   Setter 注入 @Autowired on setter 适用于可"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://iluis.cn/img/luis/bg2.png"><meta property="article:published_time" content="2025-05-20T05:46:59.000Z"><meta property="article:modified_time" content="2025-06-08T10:32:05.677Z"><meta property="article:author" content="Luis"><meta property="article:tag" content="Spring"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://iluis.cn/img/luis/bg2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://iluis.cn/5d782798.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Luis","link":"链接: ","source":"来源: LuisのBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}
</script><div id="myscoll"></div><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"SpringBoot 知识梳理",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-06-08 18:32:05"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/cat.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/luis/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/luis/bg2.png)"><nav id="nav"><span id="blog-info"><a href="/" title="LuisのBlog"><span class="site-name">LuisのBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SpringBoot 知识梳理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-20T05:46:59.000Z" title="发表于 2025-05-20 13:46:59">2025-05-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-08T10:32:05.677Z" title="更新于 2025-06-08 18:32:05">2025-06-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring/">Spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SpringBoot 知识梳理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="IOC-控制反转"><a href="#IOC-控制反转" class="headerlink" title="IOC 控制反转"></a>IOC 控制反转</h1><p>将bean的创建交给spring处理，无需关心创建细节。Spring IoC（控制反转）容器是其框架的核心，负责管理应用对象的生命周期和依赖关系。</p><h2 id="IoC-的实现方式：依赖注入（DI）"><a href="#IoC-的实现方式：依赖注入（DI）" class="headerlink" title="IoC 的实现方式：依赖注入（DI）"></a>IoC 的实现方式：依赖注入（DI）</h2><table><thead><tr><th>方式</th><th>示例</th><th>特点</th></tr></thead><tbody><tr><td>构造函数注入</td><td><code>@Autowired</code> on constructor</td><td>适用于强依赖、不可为空的场景</td></tr><tr><td>Setter 注入</td><td><code>@Autowired</code> on setter</td><td>适用于可选依赖</td></tr><tr><td>字段注入（推荐少用）</td><td><code>@Autowired</code> on field</td><td>简单快速，但不利于单元测试与封装</td></tr></tbody></table><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><ul><li>被 IoC 容器管理的对象。</li><li>使用 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等注解声明，或通过 XML 注册。</li></ul><h3 id="ApplicationContext（IoC-容器）"><a href="#ApplicationContext（IoC-容器）" class="headerlink" title="ApplicationContext（IoC 容器）"></a>ApplicationContext（IoC 容器）</h3><ul><li>Bean 的工厂 - 上下文环境。</li><li>负责创建、管理、装配、销毁所有 Bean。</li></ul><h1 id="Spring-IoC-容器解析过程"><a href="#Spring-IoC-容器解析过程" class="headerlink" title="Spring IoC 容器解析过程"></a>Spring IoC 容器解析过程</h1><h2 id="配置源加载"><a href="#配置源加载" class="headerlink" title="配置源加载"></a><strong>配置源加载</strong></h2><p>容器启动时，需要读取配置信息。</p><p>配置源类型：XML 配置文件、Java 注解、Java Config</p><p>容器：根据指定的配置源加载配置信息</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext</span><br><span class="line">AnnotationConfigApplicationContext</span><br><span class="line">FileSystemXmlApplicationContext</span><br></pre></td></tr></table></figure><h2 id="Bean-定义解析"><a href="#Bean-定义解析" class="headerlink" title="Bean 定义解析"></a><strong>Bean 定义解析</strong></h2><p>容器读取配置信息，将其解析成内部的 <code>BeanDefinition</code><br>对象。</p><p><code>BeanDefinition</code>是容器对 Bean 的抽象描述，包含关键元数据：</p><ul><li>Bean 的类名 (Class)</li><li>Bean 的作用域 (Scope - singleton, prototype 等)</li><li>是否延迟初始化 (lazy-init)</li><li>初始化方法名称 (init-method)</li><li>销毁方法名称 (destroy-method)</li><li>依赖关系信息：构造函数参数、需要注入的属性&#x2F;字段等</li><li>工厂方法信息（如果适用）。</li></ul><h2 id="Bean-定义注册"><a href="#Bean-定义注册" class="headerlink" title="Bean 定义注册"></a><strong>Bean 定义注册</strong></h2><p>解析得到的 <code>BeanDefinition</code>对象被注册到容器内部的 <code>BeanDefinitionRegistry</code>（通常由 <code>ApplicationContext</code>实现）中。这就像一个存放所有<br>Bean 蓝图的仓库。</p><h2 id="容器实例化与初始化"><a href="#容器实例化与初始化" class="headerlink" title="容器实例化与初始化"></a>容器实例化与初始化</h2><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a><strong>实例化</strong></h3><p>容器根据 <code>BeanDefinition</code>中的类信息，通过反射<strong>（<code>Class.newInstance()</code>或更复杂的构造器处理）或指定的</strong>工厂方法来创建<br>Bean 的原始对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</span><br><span class="line"><span class="comment">// 创建bean</span></span><br><span class="line">AbstractAutowireCapableBeanFactory#createBean</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置属性值</span></span><br><span class="line">AbstractAutowireCapableBeanFactory#populateBean</span><br></pre></td></tr></table></figure><h3 id="依赖注入-DI"><a href="#依赖注入-DI" class="headerlink" title="依赖注入 (DI)"></a><strong>依赖注入 (DI)</strong></h3><p>这是 IoC的核心步骤。容器查看 <code>BeanDefinition</code>中记录的依赖关系（需要注入的属性、构造器参数、方法参数）。</p><p>容器在它管理的 Bean集合（<code>BeanFactory</code>）中查找这些依赖项（其他 Bean 或简单值）。</p><p><strong>构造器注入、Setter 注入、字段注入【不推荐（不利于测试、破坏封装）】</strong></p><h3 id="Aware-接口回调"><a href="#Aware-接口回调" class="headerlink" title="Aware 接口回调"></a><strong>Aware 接口回调</strong></h3><p>如果 Bean实现了特定的 <code>Aware</code>接口（如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>, <code>ApplicationContextAware</code>, <code>EnvironmentAware</code><br>等），容器会在注入依赖之后、初始化方法之前，调用这些接口的方法，将相应的信息（如 Bean 自己的名字、所属的BeanFactory&#x2F;ApplicationContext<br>引用）传递给 Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory#populateBean</span><br></pre></td></tr></table></figure><h3 id="Bean-后置处理器-BeanPostProcessor-初始化前"><a href="#Bean-后置处理器-BeanPostProcessor-初始化前" class="headerlink" title="Bean 后置处理器 (BeanPostProcessor) - 初始化前"></a><strong>Bean 后置处理器 (BeanPostProcessor) - 初始化前</strong></h3><p>如果容器中注册了实现了 <code>BeanPostProcessor</code><br>接口的Bean，容器会在依赖注入之后、初始化方法之前，调用其 <code>postProcessBeforeInitialization()</code><br>方法。 这是对 Bean 进行额外处理（如修改 Bean 属性、生成代理）的扩展点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization</span><br></pre></td></tr></table></figure><p><code>@PostConstruct</code>是 JSR-250 标准注解，推荐使用，在这里被调用</p><h3 id="初始化方法调用"><a href="#初始化方法调用" class="headerlink" title="初始化方法调用"></a><strong>初始化方法调用</strong></h3><ul><li>如果 Bean实现了 <code>InitializingBean</code>接口，调用其 <code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置中指定了自定义的初始化方法（XML的 <code>init-method</code>属性，注解的 <code>@PostConstruct</code>方法，Java<br>Config的 <code>initMethod</code>属性），调用该方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory#invokeInitMethods</span><br></pre></td></tr></table></figure><h3 id="Bean-后置处理器-BeanPostProcessor-初始化后"><a href="#Bean-后置处理器-BeanPostProcessor-初始化后" class="headerlink" title="Bean 后置处理器 (BeanPostProcessor) - 初始化后"></a>Bean 后置处理器 (BeanPostProcessor) - 初始化后</h3><p>容器调用所有 <code>BeanPostProcessor</code>的 <code>postProcessAfterInitialization()</code>方法。</p><p>这是 AOP动态代理生成的关键阶段（如 <code>AbstractAutoProxyCreator</code>）。经过这一步，返回给应用程序的 Bean 可能是原始<br>Bean，也可能是其包装&#x2F;代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization</span><br></pre></td></tr></table></figure><h2 id="Bean-使用"><a href="#Bean-使用" class="headerlink" title="Bean 使用"></a><strong>Bean 使用</strong></h2><p>初始化完成后的 Bean实例被放入容器的单例池（对于 <code>singleton</code>作用域）或准备好被获取（对于 <code>prototype</code>）。</p><p>应用程序代码通过 <code>ApplicationContext.getBean()</code>方法（不推荐直接使用，应优先使用依赖注入）或更常见的是通过依赖注入自动获得完全组装好、可用的Bean实例。</p><h2 id="Bean-销毁"><a href="#Bean-销毁" class="headerlink" title="Bean 销毁"></a><strong>Bean 销毁</strong></h2><p>当容器关闭时（调用 <code>ApplicationContext.close()</code>），对于 <code>singleton</code>Bean，容器会管理其销毁：</p><ul><li><p>调用实现了 <code>DisposableBean</code>接口的 Bean的 <code>destroy()</code>方法。</p></li><li><p>调用配置中指定的自定义销毁方法（XML的 <code>destroy-method</code>属性，注解的 <code>@PreDestroy</code>方法，Java Config的 <code>destroyMethod</code>属性）。</p></li><li><p><code>@PreDestroy</code>是 JSR-250 标准注解，推荐使用</p></li><li><p><code>prototype</code>Bean 的销毁生命周期不由容器管理，需要使用者自行处理。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.support.DisposableBeanAdapter#destroy</span><br><span class="line"></span><br><span class="line">DisposableBeanAdapter#destroy</span><br></pre></td></tr></table></figure><h2 id="Spring-Bean-初始化过程"><a href="#Spring-Bean-初始化过程" class="headerlink" title="Spring Bean 初始化过程"></a>Spring Bean 初始化过程</h2><p><img src="/image/code-adventure/spring/assets/SpringBean%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.jpg" alt="SpringBean初始化过程"></p><h1 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h1><p>AbstractAutowireCapableBeanFactory#doCreateBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</span><br></pre></td></tr></table></figure><h1 id="Spring-Boot-启动流程"><a href="#Spring-Boot-启动流程" class="headerlink" title="Spring Boot 启动流程"></a>Spring Boot 启动流程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime(); <span class="comment">// 记录启动开始时间。用于后续计算启动耗时。</span></span><br><span class="line">        <span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> createBootstrapContext();    <span class="comment">// 创建BootstrapContext用于早期初始化；Spring Boot 2.4 引入的新机制，用于支持 BootstrapRegistryInitializer（主要用于 AOT 和原生镜像）。</span></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        configureHeadlessProperty(); <span class="comment">// 确保无图形界面环境运行；设置 Java AWT 的 headless 模式（服务器环境默认设置为 true）。</span></span><br><span class="line">        <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args); <span class="comment">// 获取监听器并初始化 SpringApplicationRunListeners，用于发布应用启动生命周期事件。通过SpringFactoriesLoader加载SpringApplicationRunListener实现类（如EventPublishingRunListener）</span></span><br><span class="line">        listeners.starting(bootstrapContext, <span class="built_in">this</span>.mainApplicationClass); <span class="comment">// 发布应用启动开始事件。触发 ApplicationStartingEvent，这是第一个生命周期事件。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);  <span class="comment">// 封装命令行参数，便于后续使用。</span></span><br><span class="line">            <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments); <span class="comment">// 准备环境，包括创建、配置、刷新环境。加载配置源（application.properties/YAML），并发布 ApplicationEnvironmentPreparedEvent。</span></span><br><span class="line">            configureIgnoreBeanInfo(environment); <span class="comment">// 设置 Environment 的 ignoreBeanInfo 属性，用于控制是否忽略 BeanInfo 文件。优化启动性能，跳过部分Bean元数据扫描。</span></span><br><span class="line">            <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment); <span class="comment">// 输出 Banner。</span></span><br><span class="line">            context = createApplicationContext();  <span class="comment">// 创建 ApplicationContext。根据应用类型（Servlet/Reactive）实例化AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">            context.setApplicationStartup(<span class="built_in">this</span>.applicationStartup); <span class="comment">// 绑定应用启动过程指标收集器</span></span><br><span class="line">            prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner); <span class="comment">// 准备上下文环境：设置环境、注册 bean、加载 主配置类 ApplicationContextInitializer、ApplicationListener，并发布 ApplicationContextInitializedEvent 和 ApplicationPreparedEvent。</span></span><br><span class="line">            refreshContext(context); <span class="comment">// 触发Bean加载、依赖注入、生命周期处理器初始化等。</span></span><br><span class="line">            afterRefresh(context, applicationArguments); <span class="comment">// 提供扩展点（默认为空方法），用户可以自定义 SpringApplication 子类并覆写。</span></span><br><span class="line">            <span class="type">Duration</span> <span class="variable">timeTakenToStartup</span> <span class="operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup); <span class="comment">// 使用 StartupInfoLogger 打印启动耗时日志。</span></span><br><span class="line">            &#125;</span><br><span class="line">            listeners.started(context, timeTakenToStartup); <span class="comment">// 发布 ApplicationStartedEvent，Spring 容器已启动完成，但 CommandLineRunner/ ApplicationRunner 未执行。</span></span><br><span class="line">            callRunners(context, applicationArguments); <span class="comment">// 调用 CommandLineRunner/ ApplicationRunner。（例如用于执行数据初始化、打印信息等逻辑）。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            handleRunFailure(context, ex, listeners);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Duration</span> <span class="variable">timeTakenToReady</span> <span class="operator">=</span> Duration.ofNanos(System.nanoTime() - startTime); <span class="comment">// 计算总耗时：包含Runner执行时间。</span></span><br><span class="line">            listeners.ready(context, timeTakenToReady); <span class="comment">// 发布 ApplicationReadyEvent，Spring 容器已启动完成，CommandLineRunner/ ApplicationRunner 已执行。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            handleRunFailure(context, ex, <span class="literal">null</span>);  <span class="comment">// 关闭上下文、输出错误日志、触发failed事件。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期事件简表"><a href="#生命周期事件简表" class="headerlink" title="生命周期事件简表"></a>生命周期事件简表</h2><p>所在类：SpringApplicationRunListeners</p><table><thead><tr><th><strong>事件类型</strong></th><th><strong>触发时机</strong></th></tr></thead><tbody><tr><td><code>ApplicationStartingEvent</code></td><td>应用启动开始时（尚未创建 Environment）</td></tr><tr><td><code>ApplicationEnvironmentPreparedEvent</code></td><td>环境准备完成（尚未创建上下文）</td></tr><tr><td><code>ApplicationContextInitializedEvent</code></td><td><code>ApplicationContext</code>初始化完成，刷新前</td></tr><tr><td><code>ApplicationPreparedEvent</code></td><td>Bean 定义加载后，刷新前</td></tr><tr><td><code>ApplicationStartedEvent</code></td><td>上下文刷新完成，CommandLineRunner 调用前</td></tr><tr><td><code>ApplicationReadyEvent</code></td><td>所有初始化和 Runner 完成（健康检查通过）</td></tr><tr><td><code>ApplicationFailedEvent</code></td><td>启动失败时</td></tr></tbody></table><h1 id="SpringApplication-refreshContext"><a href="#SpringApplication-refreshContext" class="headerlink" title="SpringApplication#refreshContext"></a>SpringApplication#refreshContext</h1><h2 id="核心流程拆解"><a href="#核心流程拆解" class="headerlink" title="核心流程拆解"></a>核心流程拆解</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>prepareRefresh()</code></td><td>初始化容器状态，设置启动时间，校验环境变量等。</td></tr><tr><td><code>obtainFreshBeanFactory()</code></td><td>获取&#x2F;刷新 <code>BeanFactory</code>：扫描配置类、注册所有 BeanDefinition（但未实例化）。</td></tr><tr><td><code>prepareBeanFactory(beanFactory)</code></td><td>设置 <code>BeanFactory</code> 的各种属性 （如类加载器、注册一些特殊的 bean，如 <code>environment</code>、<code>resourceLoader</code>）。</td></tr><tr><td><code>postProcessBeanFactory(beanFactory)</code></td><td>BeanFactory 后处理扩展点（模板方法，通常由子类实现）。</td></tr><tr><td><code>invokeBeanFactoryPostProcessors(beanFactory)</code></td><td>执行所有 <code>BeanFactoryPostProcessor</code>，如 <code>@ConfigurationProperties</code>、<code>@ComponentScan</code> 等起作用的关键步骤。</td></tr><tr><td><code>registerBeanPostProcessors(beanFactory)</code></td><td>注册所有 <code>BeanPostProcessor</code>，如 AOP、事务、@Autowired 解析器。</td></tr><tr><td><code>initMessageSource()</code></td><td>初始化 <code>MessageSource</code>，用于国际化。</td></tr><tr><td><code>initApplicationEventMulticaster()</code></td><td>初始化事件广播器，用于事件发布。</td></tr><tr><td><code>onRefresh()</code></td><td>特定子类的扩展点（如 Spring Boot 会创建内嵌 Tomcat）。</td></tr><tr><td><code>registerListeners()</code></td><td>注册所有监听器，并将早期事件缓存派发出去。</td></tr><tr><td><code>finishBeanFactoryInitialization(beanFactory)</code></td><td><strong>实例化所有非懒加载单例 Bean</strong>，执行依赖注入。</td></tr><tr><td><code>finishRefresh()</code></td><td>发布 <code>ContextRefreshedEvent</code>，启动 <code>LifecycleProcessor</code>，清除资源缓存，标志容器刷新完成。</td></tr></tbody></table><h2 id="关键步骤详解"><a href="#关键步骤详解" class="headerlink" title="关键步骤详解"></a>关键步骤详解</h2><h3 id="Bean-Factory-后置处理-invokeBeanFactoryPostProcessors"><a href="#Bean-Factory-后置处理-invokeBeanFactoryPostProcessors" class="headerlink" title="Bean Factory 后置处理 (invokeBeanFactoryPostProcessors)"></a>Bean Factory 后置处理 (<code>invokeBeanFactoryPostProcessors</code>)</h3><p>核心处理器：<code>ConfigurationClassPostProcessor</code></p><p>关键操作:</p><ul><li>扫描 <code>@ComponentScan</code> 指定的包</li><li>解析 <code>@Configuration</code>类</li><li>处理 <code>@Import</code><br>注解（包括自动配置 <code>@EnableAutoConfiguration</code>）</li><li>注册 <code>@Bean</code>方法</li></ul><p><strong>Spring Boot 扩展</strong><br>加载 <code>META-INF/spring.factories</code> 中的自动配置类，执行 <code>AutoConfigurationImportSelector</code>选择有效配置</p><h3 id="Bean-后置处理器注册-registerBeanPostProcessors"><a href="#Bean-后置处理器注册-registerBeanPostProcessors" class="headerlink" title="Bean 后置处理器注册 (registerBeanPostProcessors)"></a>Bean 后置处理器注册 (<code>registerBeanPostProcessors</code>)</h3><p>注册核心处理器：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 处理 @Autowired</span><br><span class="line">AutowiredAnnotationBeanPostProcessor</span><br><span class="line"></span><br><span class="line">// 处理 @Resource</span><br><span class="line">CommonAnnotationBeanPostProcessor</span><br><span class="line"></span><br><span class="line">// JPA 支持</span><br><span class="line">PersistenceAnnotationBeanPostProcessor</span><br><span class="line"></span><br><span class="line">// 处理 @EventListener</span><br><span class="line">EventListenerMethodProcessor</span><br></pre></td></tr></table></figure><h3 id="Bean-实例化-finishBeanFactoryInitialization"><a href="#Bean-实例化-finishBeanFactoryInitialization" class="headerlink" title="Bean 实例化 (finishBeanFactoryInitialization)"></a>Bean 实例化 (<code>finishBeanFactoryInitialization</code>)</h3><ul><li>核心方法: <code>DefaultListableBeanFactory.preInstantiateSingletons()</code></li><li><strong>处理流程</strong>：<ol><li>遍历所有 Bean 定义</li><li>实例化非懒加载的单例 Bean</li><li>执行依赖注入（字段注入、构造器注入）</li><li>调用初始化回调</li><li>应用 Bean 后置处理器（<strong>AOP代理在此阶段生成</strong>）</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">└── BeanFactoryPostProcessor</span><br><span class="line">└── BeanDefinitionRegistryPostProcessor</span><br><span class="line">└── InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</span><br><span class="line">└── 构造器</span><br><span class="line">└── InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</span><br><span class="line">└── 属性填充</span><br><span class="line">└── BeanPostProcessor.postProcessBeforeInitialization</span><br><span class="line">└── @PostConstruct</span><br><span class="line">└── InitializingBean.afterPropertiesSet</span><br><span class="line">└── BeanPostProcessor.postProcessAfterInitialization</span><br><span class="line">└── @PreDestroy/DisposableBean.destroy</span><br><span class="line">└── DestructionAwareBeanPostProcessor.postProcessBeforeDestruction</span><br></pre></td></tr></table></figure><h1 id="Spring-如何解决循环依赖，三级缓存的意义"><a href="#Spring-如何解决循环依赖，三级缓存的意义" class="headerlink" title="Spring 如何解决循环依赖，三级缓存的意义"></a>Spring 如何解决循环依赖，三级缓存的意义</h1><p>当两个或多个 Bean 相互引用时形成闭环依赖关系，Spring 需要解决这种”先有鸡还是先有蛋”的问题。<br>Spring 通过三级缓存机制<strong>解决</strong>单例 Bean 的循环依赖问题。</p><blockquote><p>spring boot2.6之前默认支持。</p></blockquote><h2 id="循环依赖的风险"><a href="#循环依赖的风险" class="headerlink" title="循环依赖的风险"></a>循环依赖的风险</h2><ul><li><strong>构造器注入的循环依赖</strong>（如 A 构造函数需要 B，B 构造函数又需要 A）：Spring无法处理，会抛出异常。</li><li><strong>Setter &#x2F; 字段注入的循环依赖</strong>：Spring 可以通过提前暴露 bean 的引用解决（三级缓存机制）。</li></ul><h2 id="循环依赖的解决限制"><a href="#循环依赖的解决限制" class="headerlink" title="循环依赖的解决限制"></a>循环依赖的解决限制</h2><h3 id="支持的情况"><a href="#支持的情况" class="headerlink" title="支持的情况"></a>支持的情况</h3><table><thead><tr><th><strong>依赖类型</strong></th><th><strong>是否支持</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Setter 注入</td><td>✅</td><td>属性注入阶段解决依赖</td></tr><tr><td>Field 注入</td><td>✅</td><td>同 Setter 注入</td></tr><tr><td>单例 Bean</td><td>✅</td><td>三级缓存机制生效</td></tr></tbody></table><h3 id="不支持的情况"><a href="#不支持的情况" class="headerlink" title="不支持的情况"></a>不支持的情况</h3><table><thead><tr><th><strong>场景</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><strong>构造器注入</strong></td><td>实例化前就需要依赖对象，无法提前暴露半成品 Bean</td></tr><tr><td><strong>原型(Prototype)</strong></td><td>Spring 不缓存原型 Bean，每次创建都是新实例</td></tr><tr><td><strong>异步初始化</strong></td><td>异步线程中无法保证缓存状态一致性</td></tr><tr><td><strong>@Async 代理</strong></td><td>代理机制在初始化后执行，无法在依赖注入时提供代理对象</td></tr></tbody></table><h2 id="Spring-三级缓存机制（解决“属性注入”循环依赖的核心）"><a href="#Spring-三级缓存机制（解决“属性注入”循环依赖的核心）" class="headerlink" title="Spring 三级缓存机制（解决“属性注入”循环依赖的核心）"></a>Spring 三级缓存机制（解决“属性注入”循环依赖的核心）</h2><p>Spring在 <code>DefaultSingletonBeanRegistry</code>中维护了 3 级缓存：</p><table><thead><tr><th>缓存名称</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td><code>singletonObjects</code></td><td>一级缓存</td><td>存放完整创建好的 Bean 实例</td></tr><tr><td><code>earlySingletonObjects</code></td><td>二级缓存</td><td>存放<strong>早期暴露的半成品 Bean</strong>（已实例化但未注入依赖）</td></tr><tr><td><code>singletonFactories</code></td><td>三级缓存</td><td>存放<strong>ObjectFactory</strong>（可创建半成品 Bean 引用）</td></tr></tbody></table><p>源码</p><ul><li>singletonsCurrentlyInCreation：保存当前正在创建的 bean 的名称。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前正在创建的 bean 的名称。*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation =</span><br><span class="line">            Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">        <span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);    <span class="comment">// 检查一级缓存 → 无</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; <span class="comment">// 并且不是当前正在创建的bean</span></span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);    <span class="comment">// 检查二级缓存 → 无</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">                    <span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">                    singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                        singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName); <span class="comment">// double check lock</span></span><br><span class="line">                        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                            ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                            <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;    <span class="comment">// 检查三级缓存 → 找到 BeanA 工厂</span></span><br><span class="line">                                singletonObject = singletonFactory.getObject();    <span class="comment">// 通过工厂获取 BeanA 的早期引用</span></span><br><span class="line">                                <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);    <span class="comment">// 移动到二级缓存</span></span><br><span class="line">                                <span class="built_in">this</span>.singletonFactories.remove(beanName);    <span class="comment">// 移除该bean工厂</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环依赖解决流程图解"><a href="#循环依赖解决流程图解" class="headerlink" title="循环依赖解决流程图解"></a>循环依赖解决流程图解</h2><p><img src="/image/code-adventure/spring/assets/Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.svg" alt="Spring解决循环依赖处理流程"></p><h2 id="三级缓存的核心意义"><a href="#三级缓存的核心意义" class="headerlink" title="三级缓存的核心意义"></a>三级缓存的核心意义</h2><h3 id="各缓存层级的职责"><a href="#各缓存层级的职责" class="headerlink" title="各缓存层级的职责"></a>各缓存层级的职责</h3><table><thead><tr><th><strong>缓存级别</strong></th><th><strong>存储内容</strong></th><th><strong>作用周期</strong></th><th><strong>关键意义</strong></th></tr></thead><tbody><tr><td><strong>一级缓存</strong></td><td>完全初始化的 Bean</td><td>整个应用生命周期</td><td>提供最终可用的 Bean</td></tr><tr><td><strong>二级缓存</strong></td><td>提前暴露的 Bean（半成品）</td><td>解决循环依赖期间</td><td>避免重复创建代理对象</td></tr><tr><td><strong>三级缓存</strong></td><td>创建 Bean 的工厂对象</td><td>Bean 实例化后到初始化前</td><td>支持 AOP 代理的延迟创建</td></tr></tbody></table><h3 id="总结：为什么需要三级缓存"><a href="#总结：为什么需要三级缓存" class="headerlink" title="总结：为什么需要三级缓存"></a>总结：为什么需要三级缓存</h3><table><thead><tr><th><strong>缓存级别</strong></th><th><strong>作用</strong></th><th><strong>解决两级缓存问题的关键点</strong></th></tr></thead><tbody><tr><td><strong>三级缓存</strong><br><code>singletonFactoris</code></td><td><strong>存储</strong> <code>ObjectFactory</code>，用于在需要暴露早期引用时，按需调用 <code>getEarlyBeanReference()</code>生成代理对象（或返回原始对象）。**</td><td><strong>延迟代理创建：</strong> 仅在循环依赖被触发、需要注入早期引用时，才<strong>按需创建代理</strong>。<br>确保注入给其他 Bean 的早期引用就是最终的代理对象（如果需要代理）。</td></tr><tr><td><strong>二级缓存</strong><br><code>earlySingletonObjects</code></td><td><code>ObjectFactory</code>获取到的早期引用（可能是原始对象，也可能是代理对象）。**</td><td><strong>代理复用：</strong> 在 Bean 自身初始化完成后（<code>postProcessAfterInitialization</code>），检查二级缓存。<br>如果存在早期引用，则直接复用该引用作为最终 Bean，<strong>保证最终放入一级缓存的对象和之前注入给其他 Bean 的早期引用是同一个对象</strong>（避免创建两个代理实例）。</td></tr><tr><td><strong>一级缓存</strong><br><code>singletonObjects</code></td><td><strong>存放完全初始化好的、最终可用的单例 Bean（可能是原始对象，也可能是代理对象）。</strong></td><td>存放最终成品。</td></tr></tbody></table><h4 id="三级缓存，是-Spring-能够在存在循环依赖的情况下，正确、按需地创建-AOP代理并保证单例一致性的核心机制。-两级缓存无法替代这个作用。"><a href="#三级缓存，是-Spring-能够在存在循环依赖的情况下，正确、按需地创建-AOP代理并保证单例一致性的核心机制。-两级缓存无法替代这个作用。" class="headerlink" title="三级缓存，是 Spring 能够在存在循环依赖的情况下，正确、按需地创建 AOP代理并保证单例一致性的核心机制。 两级缓存无法替代这个作用。"></a><strong>三级缓存，是 Spring 能够在存在循环依赖的情况下，正确、按需地创建 AOP代理并保证单例一致性的核心机制。</strong> 两级缓存无法替代这个作用。</h4><p>部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactory</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">AutowireCapableBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">                exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exposedObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmartInstantiationAwareBeanPostProcessor</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// aop代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title class_">ProxyProcessorSupport</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">SmartInstantiationAwareBeanPostProcessor</span>, BeanFactoryAware &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">        <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey); <span class="comment">// 核心逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#wrapIfNecessary</span><br><span class="line"></span><br><span class="line">org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#createProxy</span><br></pre></td></tr></table></figure><h1 id="AOP失效场景"><a href="#AOP失效场景" class="headerlink" title="AOP失效场景"></a>AOP失效场景</h1><h2 id="失效场景"><a href="#失效场景" class="headerlink" title="失效场景"></a>失效场景</h2><ol><li>static方法，属于类，无法代理；</li><li>私有方法，无法代理；</li><li>自调用方法，属于内部调用，无法使用代理类；</li><li>final方法，子类无法覆盖。</li></ol><h1 id="Spring-Boot-常用拓展接口"><a href="#Spring-Boot-常用拓展接口" class="headerlink" title="Spring Boot 常用拓展接口"></a>Spring Boot 常用拓展接口</h1><table><thead><tr><th>扩展接口</th><th>执行时机</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>BeanFactoryPostProcessor</strong></td><td>Spring 容器启动，所有 Bean 定义加载后，实例化之前</td><td>修改 BeanDefinition 元数据 如属性值修改、动态注册 Bean 等</td></tr><tr><td><strong>BeanPostProcessor</strong></td><td>Bean 实例化后，初始化前后</td><td>对 Bean 实例进行加工 如代理、属性增强、AOP、注解处理等</td></tr><tr><td><strong>ApplicationContextInitializer</strong></td><td>Spring 容器刷新之前</td><td>初始化 ApplicationContext 环境，配置环境变量、动态注册 BeanDefinition 等</td></tr><tr><td><strong>ApplicationListener</strong></td><td>发布事件时触发（如容器启动、刷新、关闭、自定义事件）</td><td>监听容器生命周期事件、自定义事件，执行特定逻辑</td></tr><tr><td><strong>CommandLineRunner</strong></td><td>Spring Boot 应用启动完成后立即执行</td><td>应用启动后执行初始化逻辑 如数据加载、启动报告、任务触发</td></tr><tr><td><strong>ApplicationRunner</strong></td><td>CommandLineRunner 的升级版，启动完成后执行，支持参数解析</td><td>同 CommandLineRunner，但支持获取启动参数，执行初始化逻辑</td></tr><tr><td><strong>InitializingBean</strong></td><td>Bean 属性设置完成后，初始化方法调用前</td><td>进行初始化操作，如检查属性、启动连接、资源初始化</td></tr><tr><td><strong>DisposableBean</strong></td><td>容器关闭时调用</td><td>释放资源，关闭连接，做清理工作</td></tr><tr><td><strong>SmartLifecycle</strong></td><td>容器启动后及关闭前执行，支持自动启动和停止</td><td>管理生命周期组件，顺序启动&#x2F;停止 如消息监听器、定时任务启动</td></tr><tr><td><strong>EnvironmentPostProcessor</strong></td><td>Environment 准备后，ApplicationContext 创建前</td><td>修改或添加 Environment 配置，如加载自定义配置源</td></tr><tr><td><strong>ImportBeanDefinitionRegistrar</strong></td><td>@Configuration 类解析时注册额外 BeanDefinition</td><td>动态注册 BeanDefinition，实现复杂组件自动装配</td></tr><tr><td><strong>ImportSelector</strong></td><td>@Configuration 类处理时，选择要导入的配置类</td><td>动态决定导入哪个配置类或组件，实现按条件装配</td></tr><tr><td><strong>FactoryBean</strong></td><td>Bean 创建过程中的工厂类，可以定制 Bean 实例</td><td>复杂 Bean 实例化逻辑，如代理、连接池、工厂模式实现</td></tr><tr><td><strong>WebMvcConfigurer</strong></td><td>Spring MVC 配置初始化时调用</td><td>自定义 MVC 配置，如拦截器、消息转换器、跨域配置</td></tr><tr><td><strong>Filter</strong></td><td>Web 请求进入 DispatcherServlet 之前执行</td><td>处理请求过滤、日志、权限校验、性能监控等</td></tr><tr><td><strong>HandlerInterceptor</strong></td><td>DispatcherServlet 处理请求前后拦截执行</td><td>请求预处理、权限验证、日志统计、请求修改</td></tr><tr><td><strong>ApplicationEventPublisherAware</strong></td><td>Bean 实例化时注入 ApplicationEventPublisher</td><td>发布自定义事件</td></tr><tr><td><strong>Aware系列接口ApplicationContextAware, EnvironmentAware等</strong></td><td>Bean初始化阶段（属性注入后，初始化回调前）</td><td>获取容器基础设施 ApplicationContext、Environment</td></tr></tbody></table><h2 id="使用扩展接口的注意事项"><a href="#使用扩展接口的注意事项" class="headerlink" title="使用扩展接口的注意事项"></a>使用扩展接口的注意事项</h2><p><strong>理解执行顺序：</strong> 不同扩展接口在 Bean生命周期中的执行顺序至关重要顺序错误可能导致预期之外的行为。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">└──BeanFactoryPostProcessor</span><br><span class="line">└──BeanDefinitionRegistryPostProcessor</span><br><span class="line">└──BeanDefinitionRegistryPostProcessor</span><br><span class="line">└──InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</span><br><span class="line">└──构造器</span><br><span class="line">└──InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</span><br><span class="line">└──属性填充</span><br><span class="line">└──BeanPostProcessor.postProcessBeforeInitialization</span><br><span class="line">└──@PostConstruct</span><br><span class="line">└──InitializingBean.afterPropertiesSet</span><br><span class="line">└──BeanPostProcessor.postProcessAfterInitialization</span><br><span class="line">└──@PreDestroy/DisposableBean.destroy</span><br><span class="line">└──DestructionAwareBeanPostProcessor.postProcessBeforeDestruction</span><br></pre></td></tr></table></figure><p><strong>谨慎修改：</strong><br>在 <code>BeanFactoryPostProcessor</code>中修改 <code>BeanDefinition</code>，在 <code>BeanPostProcessor</code>中修改或包装 Bean<br>实例都是非常强大的能力，但也容易引入难以调试的问题（如破坏循环依赖处理、破坏 AOP 代理）。</p><p><strong>避免无限递归&#x2F;循环：</strong><br>在 <code>BeanPostProcessor</code>内部调用 <code>BeanFactory.getBean()</code>可能会触发其他<br>Bean的初始化，如果处理不当可能导致无限递归或循环依赖问题（即使三级缓存也可能无法解决不规范的初始化触发）。</p><p><strong>性能考虑：<code>BeanPostProcessor</code>会作用于</strong>每一个Bean，其中的逻辑应尽量高效。</p><p><strong>优先使用注解&#x2F;配置：</strong><br>对于常见的需求（如初始化&#x2F;销毁方法、属性注入、事件监听、AOP），优先考虑使用 <code>@PostConstruct</code>, <code>@PreDestroy</code>, <code>@Autowired</code>, <code>@Value</code>,<br><code>@EventListener</code>, <code>@Aspect</code>等注解或 XML&#x2F;Java 配置方式，它们通常更简洁、更声明式，且由 Spring 框架提供的标准处理器处理。</p><p><strong>单例与原型：</strong> 注意扩展接口实现类本身通常是单例的，并且需要被Spring 管理（定义为 Bean）。</p><p>掌握这些扩展接口是深入理解 Spring IoC容器工作原理、进行高级定制开发和框架集成的关键。在使用时务必清楚其作用点和潜在影响。</p><h2 id="ApplicationRunner-x2F-CommandLineRunner-启动后逻辑执行"><a href="#ApplicationRunner-x2F-CommandLineRunner-启动后逻辑执行" class="headerlink" title="ApplicationRunner &#x2F; CommandLineRunner 启动后逻辑执行"></a><code>ApplicationRunner</code> &#x2F; <code>CommandLineRunner</code> 启动后逻辑执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt; Application Started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt; CommandLineRunner run: &quot;</span> - Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码：</p><ul><li>org.springframework.boot.SpringApplication#callRunners</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callRunners</span><span class="params">(ApplicationContext context, ApplicationArguments args)</span> &#123;</span><br><span class="line">    List&lt;Object&gt; runners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">    runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">    AnnotationAwareOrderComparator.sort(runners); <span class="comment">// 根据sort排序</span></span><br><span class="line">    <span class="keyword">for</span> (Object runner : <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(runners)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runner <span class="keyword">instanceof</span> ApplicationRunner) &#123;</span><br><span class="line">            callRunner((ApplicationRunner) runner, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (runner <span class="keyword">instanceof</span> CommandLineRunner) &#123;</span><br><span class="line">            callRunner((CommandLineRunner) runner, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BeanPostProcessor-Bean-初始化前后增强（如自动代理）"><a href="#BeanPostProcessor-Bean-初始化前后增强（如自动代理）" class="headerlink" title="BeanPostProcessor Bean 初始化前后增强（如自动代理）"></a><code>BeanPostProcessor</code> Bean 初始化前后增强（如自动代理）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before init: &quot;</span> - beanName);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean.getClass().isAnnotationPresent(Service.class)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Enhance @Service bean: &quot;</span> - beanName);</span><br><span class="line">            <span class="comment">// 可以在此返回代理对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ApplicationListener-监听容器事件"><a href="#ApplicationListener-监听容器事件" class="headerlink" title="ApplicationListener 监听容器事件"></a><code>ApplicationListener</code> 监听容器事件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyContextListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Spring Context Refreshed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SmartInitializingSingleton-所有单例-Bean-创建完成后回调一次"><a href="#SmartInitializingSingleton-所有单例-Bean-创建完成后回调一次" class="headerlink" title="SmartInitializingSingleton  所有单例 Bean 创建完成后回调一次"></a>SmartInitializingSingleton 所有单例 Bean 创建完成后回调一次</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySmartInit</span> <span class="keyword">implements</span> <span class="title class_">SmartInitializingSingleton</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterSingletonsInstantiated</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;All singletons are created.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DisposableBean-amp-InitializingBean-生命周期管理"><a href="#DisposableBean-amp-InitializingBean-生命周期管理" class="headerlink" title="DisposableBean &amp; InitializingBean 生命周期管理"></a><code>DisposableBean</code> &amp; <code>InitializingBean</code> 生命周期管理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyBean initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyBean destroyed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Autowired-x2F-Resource"><a href="#Autowired-x2F-Resource" class="headerlink" title="@Autowired&#x2F;@Resource"></a><code>@Autowired</code>&#x2F;@Resource</h1><table><thead><tr><th>比较维度</th><th><code>@Autowired</code></th><th><code>@Resource</code></th></tr></thead><tbody><tr><td>所属包</td><td><code>org.springframework.beans.factory.annotation</code></td><td><code>javax.annotation</code> （JDK 提供）</td></tr><tr><td>是否为 Spring 注解</td><td>是（Spring 独有）</td><td>否（Java 标准注解，Spring 也支持）</td></tr><tr><td>注入方式</td><td>默认按 <strong>类型</strong> 注入（byType）</td><td>默认按 <strong>名称</strong> 注入（byName），找不到再按类型注入</td></tr><tr><td>是否支持 <code>@Primary</code></td><td>支持</td><td>不支持</td></tr><tr><td>是否支持 <code>@Qualifier</code></td><td>支持，指定具体 Bean 名称</td><td>不支持 <code>@Qualifier</code> 但可通过 <code>name</code>属性指定</td></tr><tr><td>常用属性</td><td><code>required</code> （默认 true，表示是否必须注入）</td><td><code>name</code>（指定 Bean 名称） 找不到默认值null</td></tr><tr><td>作用目标</td><td>构造方法、字段、setter 方法</td><td>字段、setter 方法</td></tr><tr><td>是否可用于构造函数注入</td><td>支持（配合构造器）</td><td>不支持构造函数注入</td></tr><tr><td>推荐使用场景</td><td>Spring 项目中更推荐，功能更强、灵活性更高</td><td>跨平台&#x2F;标准 Java 项目，或对接非 Spring 容器场景</td></tr></tbody></table><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><table><thead><tr><th>组件</th><th>接口&#x2F;类</th><th>作用</th></tr></thead><tbody><tr><td>DispatcherServlet</td><td><code>org.springframework.web.servlet.DispatcherServlet</code></td><td>前端控制器，整个 MVC 的调度核心</td></tr><tr><td>HandlerMapping</td><td><code>HandlerMapping</code></td><td>映射 URL 到 Controller</td></tr><tr><td>HandlerAdapter</td><td><code>HandlerAdapter</code></td><td>执行 Controller 方法</td></tr><tr><td>Controller</td><td><code>@Controller</code> &#x2F; <code>@RestController</code></td><td>业务处理逻辑实现</td></tr><tr><td>ViewResolver</td><td><code>ViewResolver</code></td><td>根据逻辑视图名找到具体页面</td></tr><tr><td>View</td><td><code>View</code></td><td>实际的页面渲染者，如ThymeleafView</td></tr></tbody></table><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┐</span><br><span class="line">│  用户请求（浏览器） │</span><br><span class="line">└──────┬───────┘</span><br><span class="line">       ↓</span><br><span class="line"> ┌────────────────────────┐</span><br><span class="line"> │  DispatcherServlet     │ ←→ 拦截请求的前端控制器（核心）</span><br><span class="line"> └──────┬─────────────────┘</span><br><span class="line">        ↓</span><br><span class="line"> ┌────────────────────────┐</span><br><span class="line"> │  HandlerMapping        │ ←→ 查找匹配的 Controller 方法</span><br><span class="line"> └──────┬─────────────────┘</span><br><span class="line">        ↓</span><br><span class="line"> ┌────────────────────────┐</span><br><span class="line"> │  HandlerAdapter        │ ←→ 调用 Controller 的适配器</span><br><span class="line"> └──────┬─────────────────┘</span><br><span class="line">        ↓</span><br><span class="line"> ┌────────────────────────┐</span><br><span class="line"> │   Controller           │ ←→ 执行具体业务逻辑，返回 ModelAndView 或数据</span><br><span class="line"> └──────┬─────────────────┘</span><br><span class="line">        ↓</span><br><span class="line"> ┌────────────────────────┐</span><br><span class="line"> │   ViewResolver         │ ←→ 将视图名解析为页面（如 JSP, Thymeleaf）</span><br><span class="line"> └──────┬─────────────────┘</span><br><span class="line">        ↓</span><br><span class="line"> ┌────────────────────────┐</span><br><span class="line"> │   View（页面渲染器）     │ ←→ 渲染 HTML 或返回 JSON</span><br><span class="line"> └──────┬─────────────────┘</span><br><span class="line">        ↓</span><br><span class="line">┌──────────────┐</span><br><span class="line">│  响应返回用户      │</span><br><span class="line">└──────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h1><p>Spring Boot 的事务管理基于 Spring Framework 的 _声明式事务模型_，通过 <code>@Transactional</code><br>注解简化事务配置。</p><h2 id="Transactional-注解详解"><a href="#Transactional-注解详解" class="headerlink" title="@Transactional 注解详解"></a><code>@Transactional</code> 注解详解</h2><p>定义事务属性：</p><ul><li>传播行为（Propagation）</li><li>隔离级别（Isolation）</li><li>超时时间（Timeout）</li><li>只读状态（Read-only）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        propagation = Propagation.REQUIRED, // 默认传播行为</span></span><br><span class="line"><span class="meta">        isolation = Isolation.DEFAULT,      // 默认隔离级别（使用数据库默认）</span></span><br><span class="line"><span class="meta">        timeout = 30,                       // 超时时间（秒）</span></span><br><span class="line"><span class="meta">        readOnly = false,                   // 是否只读</span></span><br><span class="line"><span class="meta">        rollbackFor = Exception.class,      // 触发回滚的异常</span></span><br><span class="line"><span class="meta">        noRollbackFor = NullPointerException.class // 不触发回滚的异常</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">businessMethod</span><span class="params">()</span> &#123; ...&#125;</span><br></pre></td></tr></table></figure><h3 id="事务传播行为（Propagation）"><a href="#事务传播行为（Propagation）" class="headerlink" title="事务传播行为（Propagation）"></a>事务传播行为（Propagation）</h3><table><thead><tr><th>传播行为</th><th>说明</th><th>是否使用当前事务</th><th>场景示例</th></tr></thead><tbody><tr><td><strong>REQUIRED</strong>（默认）</td><td>有事务则加入；否则新建事务</td><td>✅</td><td>最常用，保持一致性</td></tr><tr><td><strong>REQUIRES_NEW</strong></td><td>挂起当前事务，开启新事务</td><td>❌</td><td>子操作独立提交&#x2F;回滚</td></tr><tr><td><strong>NESTED</strong></td><td>嵌套事务，内层回滚可单独处理</td><td>✅</td><td>分阶段提交&#x2F;回滚（支持保存点）</td></tr><tr><td><strong>SUPPORTS</strong></td><td>有事务则加入，无事务就非事务执行</td><td>✅（有）</td><td>可选事务，例如只读查询</td></tr><tr><td><strong>NOT_SUPPORTED</strong></td><td>永远非事务执行，挂起当前事务</td><td>❌</td><td>执行不应受事务影响的代码</td></tr><tr><td><strong>NEVER</strong></td><td>当前不能有事务，否则抛出异常</td><td>❌</td><td>禁止在事务中调用，例如第三方接口</td></tr><tr><td><strong>MANDATORY</strong></td><td>必须存在事务，否则抛异常</td><td>✅</td><td>强制在事务上下文中执行</td></tr></tbody></table><p><strong>场景示例</strong>：</p><ul><li>订单服务（REQUIRED）调用库存服务（REQUIRES_NEW）：库存操作独立提交，不受订单事务影响。</li></ul><h3 id="事务隔离级别（Isolation）"><a href="#事务隔离级别（Isolation）" class="headerlink" title="事务隔离级别（Isolation）"></a>事务隔离级别（Isolation）</h3><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>DEFAULT</strong></td><td>-</td><td>-</td><td>-</td><td>使用数据库默认级别</td></tr><tr><td><strong>READ_UNCOMMITTED</strong></td><td>✓</td><td>✓</td><td>✓</td><td>最低隔离级别</td></tr><tr><td><strong>READ_COMMITTED</strong></td><td>✗</td><td>✓</td><td>✓</td><td>解决脏读（Oracle 默认）</td></tr><tr><td><strong>REPEATABLE_READ</strong></td><td>✗</td><td>✗</td><td>✓</td><td>解决不可重复读（MySQL 默认）</td></tr><tr><td><strong>SERIALIZABLE</strong></td><td>✗</td><td>✗</td><td>✗</td><td>最高隔离级别（性能最低）</td></tr></tbody></table><p><strong>注意</strong>：Spring的隔离级别是对数据库隔离级别的抽象，实际行为取决于数据库支持。</p><h2 id="事务失效的常见场景"><a href="#事务失效的常见场景" class="headerlink" title="事务失效的常见场景"></a>事务失效的常见场景</h2><h3 id="非-public-方法"><a href="#非-public-方法" class="headerlink" title="非 public 方法"></a>非 public 方法</h3><p><code>@Transactional</code>仅对 public 方法生效。</p><h3 id="自调用问题"><a href="#自调用问题" class="headerlink" title="自调用问题"></a>自调用问题</h3><p>类内部方法调用（未通过代理对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        updateInventory(); <span class="comment">// 自调用，事务失效！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateInventory</span><span class="params">()</span> &#123; ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：注入自身代理对象或使用 AOP上下文。</p><h3 id="异常被捕获未抛出"><a href="#异常被捕获未抛出" class="headerlink" title="异常被捕获未抛出"></a>异常被捕获未抛出</h3><p>默认只对 <code>RuntimeException</code>和 <code>Error</code>回滚，捕获后需手动回滚：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">        // ...</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">        TransactionAspectSupport.</span><br><span class="line"></span><br><span class="line">currentTransactionStatus().</span><br><span class="line"></span><br><span class="line">setRollbackOnly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程调用"><a href="#多线程调用" class="headerlink" title="多线程调用"></a>多线程调用</h3><p>事务绑定到线程，跨线程操作会导致事务上下文丢失。</p><h2 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeWithTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务逻辑</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            status.setRollbackOnly(); <span class="comment">// 手动回滚</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明式事务-x2F-编程式事务"><a href="#声明式事务-x2F-编程式事务" class="headerlink" title="声明式事务&#x2F;编程式事务"></a><strong>声明式事务&#x2F;编程式事务</strong></h2><table><thead><tr><th><strong>特性</strong></th><th><strong>声明式事务</strong> <strong>(@Transactional)</strong></th><th><strong>编程式事务</strong> <strong>(TransactionTemplate)</strong></th></tr></thead><tbody><tr><td><strong>实现方式</strong></td><td>注解驱动</td><td>代码手动控制</td></tr><tr><td><strong>侵入性</strong></td><td>低（非业务代码少）</td><td>高（需编写事务控制代码）</td></tr><tr><td><strong>灵活性</strong></td><td>中等（通过注解参数配置）</td><td>高（可在代码中精细控制）</td></tr><tr><td><strong>异常处理</strong></td><td>自动回滚（默认RuntimeException）</td><td>需手动调用 status.setRollbackOnly()</td></tr><tr><td><strong>适用场景</strong></td><td>大多数业务方法</td><td>需要精细控制事务边界的复杂场景</td></tr><tr><td><strong>代码可读性</strong></td><td>高（业务逻辑清晰）</td><td>较低（事务代码与业务代码混合）</td></tr><tr><td><strong>配置复杂度</strong></td><td>低（只需@Transactional）</td><td>中（需配置TransactionTemplate）</td></tr></tbody></table><h2 id="多线程事务如何生效"><a href="#多线程事务如何生效" class="headerlink" title="多线程事务如何生效"></a>多线程事务如何生效</h2><p>传统事务管理（如Spring的<code>@Transactional</code>）通常基于<strong>ThreadLocal</strong>实现，无法跨线程传播。</p><h3 id="避免跨线程共享事务"><a href="#避免跨线程共享事务" class="headerlink" title="避免跨线程共享事务"></a><strong>避免跨线程共享事务</strong></h3><ul><li><strong>核心原则</strong>：事务应限定在<strong>单个线程</strong>内完成，避免跨线程操作。</li><li><strong>正确做法</strong>：在主线程完成所有事务操作后，再启动异步任务。</li></ul><h3 id="为子线程开启独立事务"><a href="#为子线程开启独立事务" class="headerlink" title="为子线程开启独立事务"></a><strong>为子线程开启独立事务</strong></h3><p>使用 <strong>编程式事务管理</strong>，如Spring的<code>TransactionTemplate</code>在子线程中手动控制事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在新线程中执行事务操作</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 业务操作</span></span><br><span class="line">                serviceB.process();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                status.setRollbackOnly(); <span class="comment">// 回滚</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用异步注解-事务传播（Spring推荐）"><a href="#使用异步注解-事务传播（Spring推荐）" class="headerlink" title="使用异步注解 + 事务传播（Spring推荐）"></a><strong>使用异步注解 + 事务传播（Spring推荐）</strong></h3><p>结合 <code>@Async</code>和 <code>@Transactional</code>，为每个线程开启独立事务，但前提是被调用方法在 Spring 管理的 Bean 中，并且是通过代理调用 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span> <span class="comment">// 启用异步执行</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span> <span class="comment">// 开启新事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncTransactionalTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 此方法在新线程中运行，并有独立事务</span></span><br><span class="line">        repository.save(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需配置</strong>：</p><ul><li>开启异步支持：<code>@EnableAsync</code></li><li>配置线程池（避免资源耗尽）</li></ul><h2 id="分布式事务方案"><a href="#分布式事务方案" class="headerlink" title="分布式事务方案"></a>分布式事务方案</h2><p><strong>本地消息表</strong><br>通过消息队列 - 本地事务表保证最终一致性。</p><p><strong>Seata (AT&#x2F;TCC模式)</strong></p><ul><li>AT 模式：自动补偿型事务（基于 SQL 解析）</li><li>TCC 模式：手动补偿（Try-Confirm-Cancel）</li></ul><p><strong>Saga 模式</strong></p><ul><li>长事务解决方案，通过状态机管理补偿操作。</li></ul><p>未完待续。。。</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://iluis.cn">Luis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://iluis.cn/5d782798.html">https://iluis.cn/5d782798.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://iluis.cn" target="_blank">LuisのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="/img/luis/bg2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/a2aedf2f.html" title="MySQL 性能优化"><img class="cover" src="/img/luis/t1.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL 性能优化</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/luis/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Luis</div><div class="author-info__description">低头赶路、敬事如仪</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/iluis97"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">微信公众号: dacoder<br> Gitee: https://gitee.com/iluis<br> GitHub: https://github.com/iluis97</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IOC-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC"><span class="toc-number">1.</span> <span class="toc-text">IOC 控制反转</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IoC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">IoC 的实现方式：依赖注入（DI）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean"><span class="toc-number">1.2.1.</span> <span class="toc-text">Bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ApplicationContext%EF%BC%88IoC-%E5%AE%B9%E5%99%A8%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">ApplicationContext（IoC 容器）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-IoC-%E5%AE%B9%E5%99%A8%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">Spring IoC 容器解析过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%BA%90%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.1.</span> <span class="toc-text">配置源加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean-%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">Bean 定义解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean-%E5%AE%9A%E4%B9%89%E6%B3%A8%E5%86%8C"><span class="toc-number">2.3.</span> <span class="toc-text">Bean 定义注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.4.</span> <span class="toc-text">容器实例化与初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">2.4.1.</span> <span class="toc-text">实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-DI"><span class="toc-number">2.4.2.</span> <span class="toc-text">依赖注入 (DI)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Aware-%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83"><span class="toc-number">2.4.3.</span> <span class="toc-text">Aware 接口回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8-BeanPostProcessor-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%89%8D"><span class="toc-number">2.4.4.</span> <span class="toc-text">Bean 后置处理器 (BeanPostProcessor) - 初始化前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">2.4.5.</span> <span class="toc-text">初始化方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8-BeanPostProcessor-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E"><span class="toc-number">2.4.6.</span> <span class="toc-text">Bean 后置处理器 (BeanPostProcessor) - 初始化后</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean-%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.</span> <span class="toc-text">Bean 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean-%E9%94%80%E6%AF%81"><span class="toc-number">2.6.</span> <span class="toc-text">Bean 销毁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Bean-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">Spring Bean 初始化过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text">三级缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Boot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">Spring Boot 启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6%E7%AE%80%E8%A1%A8"><span class="toc-number">4.1.</span> <span class="toc-text">生命周期事件简表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringApplication-refreshContext"><span class="toc-number">5.</span> <span class="toc-text">SpringApplication#refreshContext</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E6%8B%86%E8%A7%A3"><span class="toc-number">5.1.</span> <span class="toc-text">核心流程拆解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.2.</span> <span class="toc-text">关键步骤详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean-Factory-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86-invokeBeanFactoryPostProcessors"><span class="toc-number">5.2.1.</span> <span class="toc-text">Bean Factory 后置处理 (invokeBeanFactoryPostProcessors)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E6%B3%A8%E5%86%8C-registerBeanPostProcessors"><span class="toc-number">5.2.2.</span> <span class="toc-text">Bean 后置处理器注册 (registerBeanPostProcessors)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean-%E5%AE%9E%E4%BE%8B%E5%8C%96-finishBeanFactoryInitialization"><span class="toc-number">5.2.3.</span> <span class="toc-text">Bean 实例化 (finishBeanFactoryInitialization)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%8C%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">6.</span> <span class="toc-text">Spring 如何解决循环依赖，三级缓存的意义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="toc-number">6.1.</span> <span class="toc-text">循环依赖的风险</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A7%A3%E5%86%B3%E9%99%90%E5%88%B6"><span class="toc-number">6.2.</span> <span class="toc-text">循环依赖的解决限制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">6.2.1.</span> <span class="toc-text">支持的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E6%94%AF%E6%8C%81%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">6.2.2.</span> <span class="toc-text">不支持的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%88%E8%A7%A3%E5%86%B3%E2%80%9C%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%E2%80%9D%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E6%A0%B8%E5%BF%83%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">Spring 三级缓存机制（解决“属性注入”循环依赖的核心）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">6.4.</span> <span class="toc-text">循环依赖解决流程图解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E6%A0%B8%E5%BF%83%E6%84%8F%E4%B9%89"><span class="toc-number">6.5.</span> <span class="toc-text">三级缓存的核心意义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%BC%93%E5%AD%98%E5%B1%82%E7%BA%A7%E7%9A%84%E8%81%8C%E8%B4%A3"><span class="toc-number">6.5.1.</span> <span class="toc-text">各缓存层级的职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">6.5.2.</span> <span class="toc-text">总结：为什么需要三级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%8C%E6%98%AF-Spring-%E8%83%BD%E5%A4%9F%E5%9C%A8%E5%AD%98%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%AD%A3%E7%A1%AE%E3%80%81%E6%8C%89%E9%9C%80%E5%9C%B0%E5%88%9B%E5%BB%BA-AOP%E4%BB%A3%E7%90%86%E5%B9%B6%E4%BF%9D%E8%AF%81%E5%8D%95%E4%BE%8B%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E3%80%82-%E4%B8%A4%E7%BA%A7%E7%BC%93%E5%AD%98%E6%97%A0%E6%B3%95%E6%9B%BF%E4%BB%A3%E8%BF%99%E4%B8%AA%E4%BD%9C%E7%94%A8%E3%80%82"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">三级缓存，是 Spring 能够在存在循环依赖的情况下，正确、按需地创建 AOP代理并保证单例一致性的核心机制。 两级缓存无法替代这个作用。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AOP%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="toc-number">7.</span> <span class="toc-text">AOP失效场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="toc-number">7.1.</span> <span class="toc-text">失效场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Boot-%E5%B8%B8%E7%94%A8%E6%8B%93%E5%B1%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.</span> <span class="toc-text">Spring Boot 常用拓展接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.1.</span> <span class="toc-text">使用扩展接口的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationRunner-x2F-CommandLineRunner-%E5%90%AF%E5%8A%A8%E5%90%8E%E9%80%BB%E8%BE%91%E6%89%A7%E8%A1%8C"><span class="toc-number">8.2.</span> <span class="toc-text">ApplicationRunner &#x2F; CommandLineRunner 启动后逻辑执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanPostProcessor-Bean-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%89%8D%E5%90%8E%E5%A2%9E%E5%BC%BA%EF%BC%88%E5%A6%82%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%90%86%EF%BC%89"><span class="toc-number">8.3.</span> <span class="toc-text">BeanPostProcessor Bean 初始化前后增强（如自动代理）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationListener-%E7%9B%91%E5%90%AC%E5%AE%B9%E5%99%A8%E4%BA%8B%E4%BB%B6"><span class="toc-number">8.4.</span> <span class="toc-text">ApplicationListener 监听容器事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SmartInitializingSingleton-%E6%89%80%E6%9C%89%E5%8D%95%E4%BE%8B-Bean-%E5%88%9B%E5%BB%BA%E5%AE%8C%E6%88%90%E5%90%8E%E5%9B%9E%E8%B0%83%E4%B8%80%E6%AC%A1"><span class="toc-number">8.5.</span> <span class="toc-text">SmartInitializingSingleton 所有单例 Bean 创建完成后回调一次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DisposableBean-amp-InitializingBean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-number">8.6.</span> <span class="toc-text">DisposableBean &amp; InitializingBean 生命周期管理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Autowired-x2F-Resource"><span class="toc-number">9.</span> <span class="toc-text">@Autowired&#x2F;@Resource</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-MVC"><span class="toc-number">10.</span> <span class="toc-text">Spring MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">10.1.</span> <span class="toc-text">执行流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-%E4%BA%8B%E5%8A%A1"><span class="toc-number">11.</span> <span class="toc-text">Spring 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Transactional-%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3"><span class="toc-number">11.1.</span> <span class="toc-text">@Transactional 注解详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%EF%BC%88Propagation%EF%BC%89"><span class="toc-number">11.1.1.</span> <span class="toc-text">事务传播行为（Propagation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%88Isolation%EF%BC%89"><span class="toc-number">11.1.2.</span> <span class="toc-text">事务隔离级别（Isolation）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF"><span class="toc-number">11.2.</span> <span class="toc-text">事务失效的常见场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E-public-%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.1.</span> <span class="toc-text">非 public 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-number">11.2.2.</span> <span class="toc-text">自调用问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%A2%AB%E6%8D%95%E8%8E%B7%E6%9C%AA%E6%8A%9B%E5%87%BA"><span class="toc-number">11.2.3.</span> <span class="toc-text">异常被捕获未抛出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">11.2.4.</span> <span class="toc-text">多线程调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">11.3.</span> <span class="toc-text">编程式事务管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1-x2F-%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">11.4.</span> <span class="toc-text">声明式事务&#x2F;编程式事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E7%94%9F%E6%95%88"><span class="toc-number">11.5.</span> <span class="toc-text">多线程事务如何生效</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E8%B7%A8%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E4%BA%8B%E5%8A%A1"><span class="toc-number">11.5.1.</span> <span class="toc-text">避免跨线程共享事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%90%AF%E7%8B%AC%E7%AB%8B%E4%BA%8B%E5%8A%A1"><span class="toc-number">11.5.2.</span> <span class="toc-text">为子线程开启独立事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%B3%A8%E8%A7%A3-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%EF%BC%88Spring%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">11.5.3.</span> <span class="toc-text">使用异步注解 + 事务传播（Spring推荐）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88"><span class="toc-number">11.6.</span> <span class="toc-text">分布式事务方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#END"><span class="toc-number">12.</span> <span class="toc-text">END</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/5d782798.html" title="SpringBoot 知识梳理"><img src="/img/luis/bg2.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="SpringBoot 知识梳理"></a><div class="content"><a class="title" href="/5d782798.html" title="SpringBoot 知识梳理">SpringBoot 知识梳理</a><time datetime="2025-05-20T05:46:59.000Z" title="发表于 2025-05-20 13:46:59">2025-05-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/a2aedf2f.html" title="MySQL 性能优化"><img src="/img/luis/t1.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="MySQL 性能优化"></a><div class="content"><a class="title" href="/a2aedf2f.html" title="MySQL 性能优化">MySQL 性能优化</a><time datetime="2025-05-17T02:21:13.000Z" title="发表于 2025-05-17 10:21:13">2025-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/58b301d4.html" title="MySQL 进阶篇"><img src="/img/luis/t1.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="MySQL 进阶篇"></a><div class="content"><a class="title" href="/58b301d4.html" title="MySQL 进阶篇">MySQL 进阶篇</a><time datetime="2025-05-16T08:00:13.000Z" title="发表于 2025-05-16 16:00:13">2025-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7a3baa07.html" title="MySQL 基础篇"><img src="/img/luis/t2.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="MySQL 基础篇"></a><div class="content"><a class="title" href="/7a3baa07.html" title="MySQL 基础篇">MySQL 基础篇</a><time datetime="2025-05-15T06:51:13.000Z" title="发表于 2025-05-15 14:51:13">2025-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d5d7710f.html" title="JVM 知识提升"><img src="/img/luis/bg2.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="JVM 知识提升"></a><div class="content"><a class="title" href="/d5d7710f.html" title="JVM 知识提升">JVM 知识提升</a><time datetime="2025-05-10T05:12:02.000Z" title="发表于 2025-05-10 13:12:02">2025-05-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/luis/bg2.png)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By Luis</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" src="/js/jquery.slim.min.js"></script><script defer="defer" data-pjax src="/js/cat.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>