<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>MySQL | LuisのBlog</title><meta name="author" content="Luis"><meta name="copyright" content="Luis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="《MySQL必知必会》  RDBMS与非RDBMS关系型数据库与非关系型数据库 非关系型数据库： 键值型数据库：Redis 文档型数据库：存储xml，json。如：MongoDB 搜索引擎型数据库：ElasticSearch 列式数据库：降低系统I&#x2F;O。HBase 图形数据库：Neo4j 检索数据准备 123456789101112131415161718192021222324252"><meta property="og:type" content="article"><meta property="og:title" content="MySQL"><meta property="og:url" content="https://iluis.cn/c24675b4.html"><meta property="og:site_name" content="LuisのBlog"><meta property="og:description" content="《MySQL必知必会》  RDBMS与非RDBMS关系型数据库与非关系型数据库 非关系型数据库： 键值型数据库：Redis 文档型数据库：存储xml，json。如：MongoDB 搜索引擎型数据库：ElasticSearch 列式数据库：降低系统I&#x2F;O。HBase 图形数据库：Neo4j 检索数据准备 123456789101112131415161718192021222324252"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://iluis.cn/img/luis/t2.jpg"><meta property="article:published_time" content="2023-02-02T06:51:13.000Z"><meta property="article:modified_time" content="2025-06-08T01:12:53.180Z"><meta property="article:author" content="Luis"><meta property="article:tag" content="MySQL8"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://iluis.cn/img/luis/t2.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://iluis.cn/c24675b4.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Luis","link":"链接: ","source":"来源: LuisのBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}
</script><div id="myscoll"></div><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"MySQL",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-06-08 09:12:53"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/cat.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/luis/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/luis/t2.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="LuisのBlog"><span class="site-name">LuisのBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-02T06:51:13.000Z" title="发表于 2023-02-02 14:51:13">2023-02-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-08T01:12:53.180Z" title="更新于 2025-06-08 09:12:53">2025-06-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote><p>《MySQL必知必会》</p></blockquote><h2 id="RDBMS与非RDBMS"><a href="#RDBMS与非RDBMS" class="headerlink" title="RDBMS与非RDBMS"></a>RDBMS与非RDBMS</h2><p>关系型数据库与非关系型数据库</p><p>非关系型数据库：</p><p>键值型数据库：Redis</p><p>文档型数据库：存储xml，json。如：MongoDB</p><p>搜索引擎型数据库：ElasticSearch</p><p>列式数据库：降低系统I&#x2F;O。HBase</p><p>图形数据库：Neo4j</p><h2 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h2><p>数据准备</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span></span><br><span class="line">DATABASE `mysql_study`<span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student`</span><br><span class="line">(</span><br><span class="line">    `id`             <span class="type">bigint</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id (自增)&#x27;</span>,</span><br><span class="line">    `name`           <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">    `student_number` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">    `description`    <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;介绍&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci COMMENT <span class="string">&#x27;学生表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(name, student_number)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;1001&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(name, student_number)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;1002&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(name, student_number)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;王五&#x27;</span>, <span class="string">&#x27;1003&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(name, student_number)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;赵六&#x27;</span>, <span class="string">&#x27;1004&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(name, student_number)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;付八&#x27;</span>, <span class="string">&#x27;1005&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(name, student_number)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;付八&#x27;</span>, <span class="string">&#x27;1006&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(name, student_number)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;付九&#x27;</span>, <span class="string">&#x27;1007&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(name, student_number)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;付八九&#x27;</span>, <span class="string">&#x27;1008&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(name, student_number)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;王四&#x27;</span>, <span class="string">&#x27;1009&#x27;</span>);</span><br></pre></td></tr></table></figure><p>基操：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">DISTINCT</span> name</span><br><span class="line"><span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">LIMIT <span class="number">2</span>,<span class="number">2</span> 指示MySQL返回从行<span class="number">2</span>开始的<span class="number">2</span>行</span><br><span class="line">。</span><br><span class="line"># 个数为开始位置</span><br><span class="line">，第二个数为要检索的行数</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student LIMIT <span class="number">2</span>,<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">以下表示意思相同</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student LIMIT <span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">返回从行<span class="number">3</span>开始的<span class="number">4</span>行</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student LIMIT <span class="number">3</span>,<span class="number">4</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student LIMIT <span class="number">4</span></span><br><span class="line"><span class="keyword">OFFSET</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">使用表明限定</span><br><span class="line"><span class="keyword">select</span> student.name</span><br><span class="line"><span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> s.name <span class="keyword">as</span> <span class="string">&#x27;学生姓名&#x27;</span></span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> s;</span><br></pre></td></tr></table></figure><blockquote><p>起始位置 &#x3D;（index-1）* pageSize</p></blockquote><h2 id="排序检索"><a href="#排序检索" class="headerlink" title="排序检索"></a>排序检索</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `name`, student_number</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> student_number;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">倒序</span><br><span class="line"><span class="keyword">select</span> `name`, student_number</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> student_number <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">按多个列排序并指定排序方向</span><br><span class="line">（正序</span><br><span class="line">、倒序</span><br><span class="line">）</span><br><span class="line"><span class="keyword">select</span> id, `name`, student_number</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> `name` <span class="keyword">ASC</span>, id <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="区分大小写和排序顺序"><a href="#区分大小写和排序顺序" class="headerlink" title="区分大小写和排序顺序"></a><strong>区分大小写和排序顺序</strong></h3><p>在对文本性的数据进行排序时，A与a相同吗？a位于B之前还是位于Z之后？这些问题不是理论问题，其答案取决于数据库如何设置。</p><p>在字典（dictionary）排序顺序中，A被视为与a相同，这是MySQL（和大多数数据库管理系统）的默认行为。但是，许多数据库管理员能够在需要时改变这种行为（如果你的数据库包含大量外语字符，可能必须这样做）。</p><p>这里，关键的问题是，如果确实需要改变这种排序顺序，用简单的<code>ORDER BY</code> 子句做不到。你必须请求数据库管理员的帮助。</p><hr><h3 id="查询最值"><a href="#查询最值" class="headerlink" title="查询最值"></a>查询最值</h3><p>使用<code>ORDER BY</code> 和<code>LIMIT</code> 的组合</p><ul><li>取出最大学号</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> student_number <span class="keyword">DESC</span> LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="ORDER-BY-子句的位置"><a href="#ORDER-BY-子句的位置" class="headerlink" title="ORDER BY 子句的位置"></a><strong><code>ORDER BY</code> 子句的位置</strong></h3><p>在给出<code>ORDER BY</code> 子句时，应该保证它位于<code>FROM</code> 子句之后。如果使用<code>LIMIT</code> ，它必须位于<code>ORDER BY</code> 之后。使用子句的次序不对将产生错误消息。</p><h2 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h2><h3 id="使用WHERE子句"><a href="#使用WHERE子句" class="headerlink" title="使用WHERE子句"></a>使用WHERE子句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> student_number <span class="operator">&gt;</span> <span class="string">&#x27;1002&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> student_number <span class="operator">&lt;&gt;</span> <span class="string">&#x27;1002&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> student_number <span class="operator">!=</span> <span class="string">&#x27;1002&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">包含 [<span class="number">1002</span>,<span class="number">1004</span>]</span><br><span class="line"><span class="keyword">SELECT</span> student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> student_number <span class="keyword">BETWEEN</span> <span class="string">&#x27;1002&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;1004&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="WHERE-子句的位置"><a href="#WHERE-子句的位置" class="headerlink" title="WHERE 子句的位置"></a><strong><code>WHERE</code> 子句的位置</strong></h4><p>在同时使用<code>ORDER BY</code> 和<code>WHERE</code> 子句时，应该让<code>ORDER BY</code> 位于<code>WHERE</code> 之后，否则将会产生错误。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> student_number <span class="operator">&gt;</span> <span class="string">&#x27;1002&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> student_number <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h4 id="空值检查"><a href="#空值检查" class="headerlink" title="空值检查"></a><strong>空值检查</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> description <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><h3 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合WHERE子句</h3><h4 id="AND-操作符"><a href="#AND-操作符" class="headerlink" title="AND 操作符"></a><strong><code>AND</code> 操作符</strong></h4><p><strong><code>AND</code></strong> 用在<code>WHERE</code> 子句中的关键字，用来指示检索满足所有给定条件的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> student_number <span class="operator">&gt;</span> <span class="string">&#x27;1002&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> `name` <span class="operator">=</span> <span class="string">&#x27;付八&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="OR-操作符"><a href="#OR-操作符" class="headerlink" title="OR 操作符"></a><strong><code>OR</code> 操作符</strong></h4><p><strong><code>OR</code></strong> 用在<code>WHERE</code> 子句中使用的关键字，用来表示检索匹配任一给定条件的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> student_number <span class="operator">=</span> <span class="string">&#x27;1002&#x27;</span></span><br><span class="line">   <span class="keyword">OR</span> `name` <span class="operator">=</span> <span class="string">&#x27;李八&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="在WHERE-子句中使用圆括号"><a href="#在WHERE-子句中使用圆括号" class="headerlink" title="在WHERE 子句中使用圆括号"></a>在<code>WHERE</code> 子句中使用圆括号</h4><p>任何时候使用具有<code>AND</code> 和<code>OR</code> 操作符的<code>WHERE</code> 子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序，即使它确实是你想要的东西也是如此。使用圆括号没有什么坏处，它能消除歧义。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">找出学号是<span class="number">1002</span>或者叫李八的并且描述不为<span class="keyword">null</span>的同学</span><br><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> (student_number <span class="operator">=</span> <span class="string">&#x27;1002&#x27;</span> <span class="keyword">OR</span> `name` <span class="operator">=</span> <span class="string">&#x27;李八&#x27;</span>)</span><br><span class="line">  <span class="keyword">AND</span> description <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h3><p>圆括号在<code>WHERE</code> 子句中还有另外一种用法。<code>IN</code> 操作符用来指定条件范围，范围中的每个条件都可以进行匹配。<code>IN</code><br>取合法值的由逗号分隔的清单，全都括在圆括号中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> student_number <span class="keyword">IN</span> (<span class="string">&#x27;1002&#x27;</span>, <span class="string">&#x27;1003&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong><code>IN</code></strong> <code>WHERE</code> 子句中用来指定要匹配值的清单的关键字，功能与<code>OR</code> <strong>相当</strong> 。</p><h4 id="为什么要使用IN-操作符"><a href="#为什么要使用IN-操作符" class="headerlink" title="为什么要使用IN 操作符"></a>为什么要使用<code>IN</code> 操作符</h4><p>其优点具体如下：</p><ul><li>在使用长的合法选项清单时，<code>IN</code> 操作符的语法更清楚且更直观。</li><li>在使用<code>IN</code> 时，计算的次序更容易管理（因为使用的操作符更少）。</li><li><code>IN</code> 操作符一般比<code>OR</code> 操作符清单执行更快。</li><li><code>IN</code> 的最大优点是可以包含其他<code>SELECT</code> 语句，使得能够更动态地建立<code>WHERE</code> 子句。</li></ul><hr><h3 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h3><p><strong><code>NOT</code></strong> <code>WHERE</code> 子句中用来否定后跟条件的关键字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> student_number <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;1002&#x27;</span>, <span class="string">&#x27;1003&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>MySQL中的<code>NOT</code></strong> MySQL支持使用<code>NOT</code> 对<code>IN</code> 、<code>BETWEEN</code> 和<code>EXISTS</code> <strong>子句取反，这与多数其他</strong> DBMS允许使用<code>NOT</code><br>对各种条件取反有很大的差别。</p><h2 id="用通配符进行过滤"><a href="#用通配符进行过滤" class="headerlink" title="用通配符进行过滤"></a><strong>用通配符进行过滤</strong></h2><h3 id="LIKE操作符"><a href="#LIKE操作符" class="headerlink" title="LIKE操作符"></a>LIKE操作符</h3><p><strong>通配符（wildcard）</strong> 用来匹配值的一部分的特殊字符。</p><p>**搜索模式（search pattern)**由字面值、通配符或两者组合构成的搜索条件。</p><p>通配符本身实际是SQL的<code>WHERE</code> 子句中有特殊含义的字符，SQL支持几种通配符。</p><p>为在搜索子句中使用通配符，必须使用<code>LIKE</code> 操作符。<code>LIKE</code> 指示MySQL，**后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较<br>**。</p><p>无通配符情况一：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;李四&#x27;</span>;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">李四	1002</span><br></pre></td></tr></table></figure><p>无通配符情况二：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;李&#x27;</span>;</span><br></pre></td></tr></table></figure><p>结果是未匹配到数据！</p><h4 id="百分号（-）通配符"><a href="#百分号（-）通配符" class="headerlink" title="百分号（% ）通配符"></a><strong>百分号（<code>%</code> ）通配符</strong></h4><p>在搜索串中，<code>%</code> 表示<em>任何字符出现任意次数</em> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;付%&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>区分大小写</strong> 根据MySQL的配置方式，搜索可以是区分大小写的。如果区分大小写，<code>&#39;jet%&#39;</code> 与<code>JetPack 1000</code> 将不匹配。</p></blockquote><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">付八	1005</span><br><span class="line">付八	1006</span><br><span class="line">付九	1007</span><br><span class="line">付八九	1008</span><br></pre></td></tr></table></figure><ul><li>两个<code>%</code>通配符</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%九%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">付九	1007</span><br><span class="line">付八九	1008</span><br></pre></td></tr></table></figure><ul><li><code>%</code>通配符在中间</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;付%九&#x27;</span>;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">付九	1007</span><br><span class="line">付八九	1008</span><br></pre></td></tr></table></figure><hr><h4 id="下划线（-）通配符"><a href="#下划线（-）通配符" class="headerlink" title="下划线（_ ）通配符"></a><strong>下划线（<code>_</code> ）通配符</strong></h4><p>下划线只匹配单个字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;付_&#x27;</span>;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">付八	1005</span><br><span class="line">付八	1006</span><br><span class="line">付九	1007</span><br></pre></td></tr></table></figure><p>与<code>%</code> 能匹配0个字符不一样，<code>_</code> 总是匹配一个字符，不能多也不能少。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       student_number</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;_九&#x27;</span>;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">付九	1007</span><br></pre></td></tr></table></figure><hr><h4 id="使用通配符的技巧"><a href="#使用通配符的技巧" class="headerlink" title="使用通配符的技巧"></a>使用通配符的技巧</h4><p>MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。</p><ul><li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li><li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。</li><li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li></ul><hr><h2 id="用正则表达式进行搜索"><a href="#用正则表达式进行搜索" class="headerlink" title="用正则表达式进行搜索"></a>用正则表达式进行搜索</h2><h3 id="基本字符匹配"><a href="#基本字符匹配" class="headerlink" title="基本字符匹配"></a><strong>基本字符匹配</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> name REGEXP <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure><p>除关键字<code>LIKE</code> 被<code>REGEXP</code> 替代外，这条语句看上去非常像使用<code>LIKE</code> 的语句（第8章）。它告诉MySQL：<code>REGEXP</code><br>后所跟的东西作为正则表达式（与文字正文<code>1000</code> 匹配的一个正则表达式）处理。</p><p>为什么要费力地使用正则表达式？在刚才的例子中，正则表达式确实没有带来太多好处（可能还会降低性能），我们接着看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> admission_info</span><br><span class="line"><span class="keyword">where</span> tuition REGEXP <span class="string">&#x27;.11&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> admission_info</span><br><span class="line"><span class="keyword">where</span> tuition <span class="keyword">LIKE</span> <span class="string">&#x27;%.11&#x27;</span>; </span><br></pre></td></tr></table></figure><p>再接着看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 表中有数据是120.11</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> admission_info</span><br><span class="line"><span class="keyword">where</span> tuition REGEXP <span class="string">&#x27;120&#x27;</span>;</span><br><span class="line">#</span><br><span class="line">返回两条数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> admission_info</span><br><span class="line"><span class="keyword">where</span> tuition <span class="keyword">LIKE</span> <span class="string">&#x27;120&#x27;</span>;</span><br><span class="line">#</span><br><span class="line">无数据返回</span><br></pre></td></tr></table></figure><p>此时出现结果差异，原因：</p><p><code>LIKE</code> 匹配整个列。如果被匹配的文本在列值中出现，<code>LIKE</code> 将不会找到它，相应的行也不被返回（除非使用通配符）。而<code>REGEXP</code><br>在列值内进行匹配，如果被匹配的文本在列值中出现，<code>REGEXP</code> 将会找到它，相应的行将被返回。这是一个非常重要的差别。</p><p><strong>匹配不区分大小写</strong></p><p>MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用<code>BINARY</code> 关键字：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> name REGEXP <span class="type">BINARY</span> <span class="string">&#x27;z3&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="进行OR-匹配"><a href="#进行OR-匹配" class="headerlink" title="进行OR 匹配"></a><strong>进行<code>OR</code> 匹配</strong></h3><p>为搜索两个串之一（或者为这个串，或者为另一个串），使用|，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">WHERE</span> goods_name REGEXP <span class="string">&#x27;卫衣|卫龙&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>两个以上的<code>OR</code> 条件</strong> 可以给出两个以上的<code>OR</code> 条件。例如，<code>&#39;1000 | 2000 | 3000&#39;</code> 将匹配<code>1000</code> 或<code>2000</code> 或<code>3000</code> 。</p><h3 id="匹配几个字符之一"><a href="#匹配几个字符之一" class="headerlink" title="匹配几个字符之一"></a><strong>匹配几个字符之一</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> `name` REGEXP <span class="string">&#x27;[张王李]三&#x27;</span> # 这句的意思是匹配 张三 <span class="keyword">or</span> 王三 <span class="keyword">or</span> 李三</span><br></pre></td></tr></table></figure><p>注意区别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    `name`</span><br><span class="line">REGEXP <span class="string">&#x27;张|王|李三&#x27;</span> # 这句的意思是匹配 张 <span class="keyword">or</span> 王 <span class="keyword">or</span> 李三</span><br></pre></td></tr></table></figure><p>字符集合也可以被否定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    `name`</span><br><span class="line">REGEXP <span class="string">&#x27;[^张王李]三&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="匹配范围"><a href="#匹配范围" class="headerlink" title="匹配范围"></a><strong>匹配范围</strong></h3><p>集合可用来定义要匹配的一个或多个字符。例如，下面的集合将匹配数字0到9：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[0123456789]</span></span><br></pre></td></tr></table></figure><p>为简化这种类型的集合，可使用<code>-</code> 来定义一个范围。下面的式子功能上等同于上述数字列表：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[0-9]</span></span><br></pre></td></tr></table></figure><p>范围不限于完整的集合，<code>[1-3]</code> 和<code>[6-9]</code> 也是合法的范围。此外，范围不一定只是数值的，<code>[a-z]</code> 匹配任意字母字符。</p><h3 id="匹配特殊字符"><a href="#匹配特殊字符" class="headerlink" title="匹配特殊字符"></a><strong>匹配特殊字符</strong></h3><p><code>.</code> 匹配任意字符，因此每个行都被检索出来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> `name` REGEXP <span class="string">&#x27;.&#x27;</span></span><br></pre></td></tr></table></figure><p>为了匹配特殊字符，必须用<code>\\</code> 为前导。<code>\\-</code> 表示查找<code>-</code> ，<code>\\.</code> 表示查找<code>.</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `tuition`</span><br><span class="line"><span class="keyword">FROM</span> admission_info</span><br><span class="line"><span class="keyword">WHERE</span> `tuition` REGEXP <span class="string">&#x27;\\.&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>空白元字符</strong>：<code>\\</code> 也用来引用元字符（具有特殊含义的字符）</p><table><thead><tr><th align="center">元 字 符</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center"><code>\\f</code></td><td align="center">换页</td></tr><tr><td align="center"><code>\\n</code></td><td align="center">换行</td></tr><tr><td align="center"><code>\\r</code></td><td align="center">回车</td></tr><tr><td align="center"><code>\\t</code></td><td align="center">制表</td></tr><tr><td align="center"><code>\\v</code></td><td align="center">纵向制表</td></tr></tbody></table><p>匹配<code>\</code></p><p>为了匹配反斜杠（<code>\</code> ）字符本身，需要使用<code>\\\</code> 。</p><p><strong><code>\</code> 或<code>\\</code></strong> ？</p><p>多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但MySQL要求两个反斜杠（MySQL自己解释一个，正则表达式库解释另一个)。</p><h3 id="匹配字符类"><a href="#匹配字符类" class="headerlink" title="匹配字符类"></a><strong>匹配字符类</strong></h3><p>存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。为更方便工作，可以使用预定义的字符集，称为<em>字符类</em><br>（characterclass）。</p><p><strong>字符类</strong></p><table><thead><tr><th align="center">类</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center"><code>[:alnum:]</code></td><td align="center">任意字母和数字（同<code>[a-zA-Z0-9]</code> ）</td></tr><tr><td align="center"><code>[:alpha:]</code></td><td align="center">任意字符（同<code>[a-zA-Z]</code> ）</td></tr><tr><td align="center"><code>[:blank:]</code></td><td align="center">空格和制表（同<code>[\\t]</code> ）</td></tr><tr><td align="center"><code>[:cntrl:]</code></td><td align="center">ASCII控制字符（ASCII <code>0</code> 到<code>31</code> 和<code>127</code> ）</td></tr><tr><td align="center"><code>[:digit:]</code></td><td align="center">任意数字（同<code>[0-9]</code> ）</td></tr><tr><td align="center"><code>[:graph:]</code></td><td align="center">与<code>[:print:]</code> 相同，但不包括空格</td></tr><tr><td align="center"><code>[:lower:]</code></td><td align="center">任意小写字母（同<code>[a-z]</code> ）</td></tr><tr><td align="center"><code>[:print:]</code></td><td align="center">任意可打印字符</td></tr><tr><td align="center"><code>[:punct:]</code></td><td align="center">既不在<code>[:alnum:]</code> 又不在<code>[:cntrl:]</code> 中的任意字符</td></tr><tr><td align="center"><code>[:space:]</code></td><td align="center">包括空格在内的任意空白字符（同<code>[\\f\\n\\r\\t\\v]</code> ）</td></tr><tr><td align="center"><code>[:upper:]</code></td><td align="center">任意大写字母（同<code>[A-Z]</code> ）</td></tr><tr><td align="center"><code>[:xdigit:]</code></td><td align="center">任意十六进制数字（同<code>[a-fA-F0-9]</code> ）</td></tr></tbody></table><h3 id="匹配多个实例"><a href="#匹配多个实例" class="headerlink" title="匹配多个实例"></a><strong>匹配多个实例</strong></h3><p><strong>重复元字符</strong></p><table><thead><tr><th align="center">元 字 符</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center"><code>*</code></td><td align="center">0个或多个匹配</td></tr><tr><td align="center"><code>+</code></td><td align="center">1个或多个匹配（等于<code>&#123;1,&#125;</code> ）</td></tr><tr><td align="center"><code>?</code></td><td align="center">0个或1个匹配（等于<code>&#123;0,1&#125;</code> ）</td></tr><tr><td align="center"><code>&#123;n&#125;</code></td><td align="center">指定数目的匹配</td></tr><tr><td align="center"><code>&#123;n,&#125;</code></td><td align="center">不少于指定数目的匹配</td></tr><tr><td align="center"><code>&#123;n,m&#125;</code></td><td align="center">匹配数目的范围（<code>m</code> 不超过255）</td></tr></tbody></table><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,</span><br><span class="line">       `name`,</span><br><span class="line">       description</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> description REGEXP <span class="string">&#x27;[[:digit:]]&#123;4&#125;&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    id;</span><br></pre></td></tr></table></figure><h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a><strong>定位符</strong></h3><p>匹配特定位置的文本。</p><p><strong>定位元字符</strong></p><table><thead><tr><th align="center">元 字 符</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center"><code>^</code></td><td align="center">文本的开始</td></tr><tr><td align="center"><code>$</code></td><td align="center">文本的结尾</td></tr><tr><td align="center"><code>[[:</code></td><td align="center">词的开始</td></tr><tr><td align="center"><code>[[:&gt;:]]</code></td><td align="center">词的结尾</td></tr></tbody></table><p>示例</p><p>如果你想找出以一个数（包括以小数点开始的数）开始的所有产品，怎么办？简单搜索<code>[0-9\\.]</code> （或<code>[[:digit:]\\.</code> ]<br>）不行，因为它将在文本内任意位置查找匹配。解决办法是使用^定位符，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- description 是数字开头，后面任意</span></span><br><span class="line"><span class="keyword">SELECT</span> id,</span><br><span class="line">       `name`,</span><br><span class="line">       description</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> description REGEXP <span class="string">&#x27;^[0-9\\.]&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    id;</span><br></pre></td></tr></table></figure><p><strong><code>^</code> 的双重用途</strong> <code>^</code> 有两种用法。在集合中（用[和]定义），用它来否定该集合，否则，用来指串的开始处。</p><p><strong>使<code>REGEXP</code> 起类似<code>LIKE</code> 的作用</strong></p><p><code>LIKE</code> 和<code>REGEXP</code> 的不同在于，<code>LIKE</code> 匹配整个串而<code>REGEXP</code> 匹配子串。利用定位符，通过用<code>^</code> 开始每个表达式，用<code>$</code><br>结束每个表达式，可以使<code>REGEXP</code> 的作用与<code>LIKE</code> 一样。</p><p><strong>简单的正则表达式测试</strong></p><p>可以在不使用数据库表的情况下用<code>SELECT</code> 来测试正则表达式。<code>REGEXP</code> 检查总是返回<code>0</code> （没有匹配）或<code>1</code><br>（匹配）。可以用带文字串的<code>REGEXP</code> 来测试表达式，并试验它们。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;hello&#x27;</span> REGEXP <span class="string">&#x27;[0-9]&#x27;</span>;</span><br></pre></td></tr></table></figure><p>结果将返回<code>0</code> （因为文本<code>hello</code> 中没有数字）。</p><hr><h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><h3 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h3><p><strong>拼接（concatenate）</strong> 将值联结到一起构成单个值。</p><p><strong>MySQL的不同之处</strong> 多数DBMS使用<code>+</code> 或<code>||</code> 来实现拼接，MySQL则使用<code>Concat()</code>函数来实现。当把SQL语句转换成MySQL语句时一定要把这个区别铭记在心。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(`name`, <span class="string">&#x27; (&#x27;</span>, student_number, <span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> `classinfo`</span><br><span class="line"><span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">张三 (1001)</span><br><span class="line">李四 (1002)</span><br><span class="line">王五 (1003)</span><br><span class="line">赵六 (1004)</span><br><span class="line">付八 (1005)</span><br><span class="line">付八 (1006)</span><br><span class="line">付九 (1007)</span><br><span class="line">付八九 (1008)</span><br><span class="line">王四 (1009)</span><br></pre></td></tr></table></figure><hr><h3 id="删除空格"><a href="#删除空格" class="headerlink" title="删除空格"></a>删除空格</h3><ul><li><p><code>RTrim()</code> 函数去掉值右边的所有空格。</p></li><li><p><code>LTrim()</code> 函数去掉串左边的空格。</p></li><li><p><code>Trim()</code> 函数去掉串左右两边的空格。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(`name`, <span class="string">&#x27; (&#x27;</span>, student_number, LTRIM(<span class="string">&#x27;  )&#x27;</span>)) <span class="keyword">AS</span> `classinfo`</span><br><span class="line"><span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><hr><h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a><strong>使用别名</strong></h3><p>一个未命名的列不能用于客户机应用中，因为客户机没有办法引用它。</p><p>为了解决这个问题，SQL支持列别名。<em>别名</em> （alias）是一个字段或值的替换名。别名用<code>AS</code> 关键字赋予。</p><p><strong>别名的其他用途</strong></p><p>别名还有其他用途。常见的用途包括在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它。</p><p><strong>导出列</strong></p><p>别名有时也称为导出列（derivedcolumn），不管称为什么，它们所代表的都是相同的东西。</p><h3 id="执行算术计算"><a href="#执行算术计算" class="headerlink" title="执行算术计算"></a>执行算术计算</h3><p>计算字段的另一常见用途是对检索出的数据进行算术计算。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       (id <span class="operator">*</span> student_number) <span class="keyword">AS</span> <span class="string">&#x27;score&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> `student`;</span><br></pre></td></tr></table></figure><p><strong>MySQL算术操作符</strong></p><table><thead><tr><th align="center">操 作 符</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center"><code>+</code></td><td align="center">加</td></tr><tr><td align="center"><code>-</code></td><td align="center">减</td></tr><tr><td align="center"><code>*</code></td><td align="center">乘</td></tr><tr><td align="center"><code>/</code></td><td align="center">除</td></tr></tbody></table><hr><h3 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h3><p><strong>函数没有SQL的可移植性强</strong></p><p>能运行在多个系统上的代码称为可移植的（portable）。相对来说，多数SQL语句是可移植的，在SQL实现之间有差异时，这些差异通常不那么难处理。而函数的可移植性却不强。几乎每种主要的DBMS的实现都支持其他实现不支持的函数，而且有时差异还很大。</p><p>为了代码的可移植，许多SQL程序员不赞成使用特殊实现的功能。虽然这样做很有好处，但不总是利于应用程序的性能。如果不使用这些函数，编写某些应用程序代码会很艰难。必须利用其他方法来实现DBMS非常有效地完成的工作。</p><p>如果你决定使用函数，应该保证做好代码注释，以便以后你（或其他人）能确切地知道所编写SQL代码的含义。</p><h4 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a><strong>文本处理函数</strong></h4><p><strong>常用的文本处理函数</strong></p><table><thead><tr><th align="center">函 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center"><code>Left()</code></td><td align="center">返回串左边的字符</td></tr><tr><td align="center"><code>Length()</code></td><td align="center">返回串的长度</td></tr><tr><td align="center"><code>Locate()</code></td><td align="center">找出串的一个子串</td></tr><tr><td align="center"><code>Lower()</code></td><td align="center">将串转换为小写</td></tr><tr><td align="center"><code>LTrim()</code></td><td align="center">去掉串左边的空格</td></tr><tr><td align="center"><code>Right()</code></td><td align="center">返回串右边的字符</td></tr><tr><td align="center"><code>RTrim()</code></td><td align="center">去掉串右边的空格</td></tr><tr><td align="center"><code>Soundex()</code></td><td align="center">返回串的<code>SOUNDEX</code> 值</td></tr><tr><td align="center"><code>SubString()</code></td><td align="center">返回子串的字符</td></tr><tr><td align="center"><code>Upper()</code></td><td align="center">将串转换为大写</td></tr></tbody></table><p><code>SOUNDEX</code> 是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。<code>SOUNDEX</code><br>考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。虽然<code>SOUNDEX</code><br>不是SQL概念，但MySQL（就像多数DBMS一样）都提供对<code>SOUNDEX</code> 的支持。</p><ul><li>SUBSTRING()</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       <span class="built_in">SUBSTRING</span>(`name`, <span class="number">1</span>, <span class="number">1</span>) <span class="keyword">AS</span> first_name</span><br><span class="line"><span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">张三	张</span><br><span class="line">李四	李</span><br><span class="line">王五	王</span><br><span class="line">赵六	赵</span><br><span class="line">付八	付</span><br><span class="line">付八	付</span><br><span class="line">付九	付</span><br><span class="line">付八九	付</span><br><span class="line">王四	王</span><br></pre></td></tr></table></figure><hr><h4 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a><strong>日期和时间处理函数</strong></h4><p>日期和时间采用相应的数据类型和特殊的格式存储，以便能快速和有效地排序或过滤，并且节省物理存储空间。</p><p>一般，应用程序不使用用来存储日期和时间的格式，因此日期和时间函数总是被用来读取、统计和处理这些值。由于这个原因，日期和时间函数在MySQL语言中具有重要的作用。</p><p><strong>常用日期和时间处理函数</strong></p><table><thead><tr><th align="center">函 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center"><code>AddDate()</code></td><td align="center">增加一个日期（天、周等）</td></tr><tr><td align="center"><code>AddTime()</code></td><td align="center">增加一个时间（时、分等）</td></tr><tr><td align="center"><code>CurDate()</code></td><td align="center">返回当前日期</td></tr><tr><td align="center"><code>CurTime()</code></td><td align="center">返回当前时间</td></tr><tr><td align="center"><code>Date()</code></td><td align="center">返回日期时间的日期部分</td></tr><tr><td align="center"><code>DateDiff()</code></td><td align="center">计算两个日期之差</td></tr><tr><td align="center"><code>Date_Add()</code></td><td align="center">高度灵活的日期运算函数</td></tr><tr><td align="center"><code>Date_Format()</code></td><td align="center">返回一个格式化的日期或时间串</td></tr><tr><td align="center"><code>Day()</code></td><td align="center">返回一个日期的天数部分</td></tr><tr><td align="center"><code>DayOfWeek()</code></td><td align="center">对于一个日期，返回对应的星期几</td></tr><tr><td align="center"><code>Hour()</code></td><td align="center">返回一个时间的小时部分</td></tr><tr><td align="center"><code>Minute()</code></td><td align="center">返回一个时间的分钟部分</td></tr><tr><td align="center"><code>Month()</code></td><td align="center">返回一个日期的月份部分</td></tr><tr><td align="center"><code>Now()</code></td><td align="center">返回当前日期和时间</td></tr><tr><td align="center"><code>Second()</code></td><td align="center">返回一个时间的秒部分</td></tr><tr><td align="center"><code>Time()</code></td><td align="center">返回一个日期时间的时间部分</td></tr><tr><td align="center"><code>Year()</code></td><td align="center">返回一个日期的年份部分</td></tr></tbody></table><p>需要注意的是MySQL使用的日期格式。无论你什么时候指定一个日期，不管是插入或更新表值还是用<code>WHERE</code> 子句进行过滤，日期必须为格式yyyy-mm-dd。</p><p><strong>应该总是使用4位数字的年份</strong></p><p>支持2位数字的年份，MySQL处理00-69为2000-2069，处理70-99为1970-1999。虽然它们可能是打算要的年份，但使用完整的4位数字年份更可靠，因为MySQL不必做出任何假定。</p><p>数据准备</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `admission_info`</span><br><span class="line">(</span><br><span class="line">    `id`             <span class="type">BIGINT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `student_id`     <span class="type">BIGINT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学生id&#x27;</span>,</span><br><span class="line">    `admission_date` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;入学时间&#x27;</span>,</span><br><span class="line">    `tuition`        <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学费&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB AUTO_INCREMENT <span class="operator">=</span> <span class="number">10</span> <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_0900_ai_ci</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `admission_info` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;2022-12-09 00:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `admission_info`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">2</span>, <span class="string">&#x27;2022-12-04 00:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `admission_info`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">3</span>, <span class="string">&#x27;2022-12-09 00:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `admission_info`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">4</span>, <span class="string">&#x27;2022-12-09 00:00:22&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `admission_info`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">5</span>, <span class="string">&#x27;2022-12-09 00:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `admission_info`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="number">6</span>, <span class="string">&#x27;2022-12-09 02:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `admission_info`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="number">7</span>, <span class="string">&#x27;2022-12-01 00:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `admission_info`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="number">8</span>, <span class="string">&#x27;2022-12-09 00:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `admission_info`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="number">9</span>, <span class="string">&#x27;2022-12-02 00:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>查询日期</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">第一种查询</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> <span class="string">&#x27;总条数&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> `admission_info`</span><br><span class="line"><span class="keyword">WHERE</span> `admission_date` <span class="operator">=</span> <span class="string">&#x27;2022-12-09&#x27;</span>;</span><br><span class="line">#</span><br><span class="line"><span class="number">4</span>条</span><br><span class="line"></span><br><span class="line"># 第二种查询 <span class="type">Date</span>()</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> <span class="string">&#x27;总条数&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> `admission_info`</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="type">Date</span> ( `admission_date` ) <span class="operator">=</span> <span class="string">&#x27;2022-12-09&#x27;</span>;</span><br><span class="line">#</span><br><span class="line"><span class="number">6</span>条</span><br></pre></td></tr></table></figure><p><strong>如果要的是日期，请使用<code>Date()</code></strong> 如果你想要的仅是日期，则使用<code>Date()</code> 是一个良好的习惯，即使你知道相应的列只包含日期也是如此。</p><p>这样，如果由于某种原因表中以后有日期和时间值，你的SQL代码也不用改变。当然，也存在一个<code>Time()</code> 函数，在你只想要时间时应该使用它。</p><ul><li>时间范围查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> `admission_info`</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="type">DATE</span> ( `admission_date` ) <span class="keyword">BETWEEN</span> <span class="string">&#x27;2022-12-01&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> <span class="string">&#x27;2022-12-05&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>查询某月的某天</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> `admission_info`</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="keyword">YEAR</span> ( `admission_date` ) <span class="operator">=</span> <span class="number">2022</span></span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">MONTH</span> ( `admission_date` ) <span class="operator">=</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a><strong>数值处理函数</strong></h4><p>数值处理函数仅处理数值数据。这些函数一般主要用于代数、三角或几何运算，因此没有串或日期—时间处理函数的使用那么频繁。</p><p><strong>常用数值处理函数</strong></p><table><thead><tr><th align="center">函 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center"><code>Abs()</code></td><td align="center">返回一个数的绝对值</td></tr><tr><td align="center"><code>Cos()</code></td><td align="center">返回一个角度的余弦</td></tr><tr><td align="center"><code>Exp()</code></td><td align="center">返回一个数的指数值</td></tr><tr><td align="center"><code>Mod()</code></td><td align="center">返回除操作的余数</td></tr><tr><td align="center"><code>Pi()</code></td><td align="center">返回圆周率</td></tr><tr><td align="center"><code>Rand()</code></td><td align="center">返回一个随机数</td></tr><tr><td align="center"><code>Sin()</code></td><td align="center">返回一个角度的正弦</td></tr><tr><td align="center"><code>Sqrt()</code></td><td align="center">返回一个数的平方根</td></tr><tr><td align="center"><code>Tan()</code></td><td align="center">返回一个角度的</td></tr></tbody></table><hr><h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><p>SQL聚集函数可用来汇总数据。这使我们能够对行进行计数，计算和与平均数，获得最大和最小值而不用检索所有数据。</p><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><ul><li>确定表中行数（或者满足某个条件或包含某个特定值的行数）。</li><li>获得表中行组的和。</li><li>找出表列（或所有行或某些特定的行）的最大值、最小值和平均值。</li></ul><p><strong>聚集函数（aggregate function）</strong> 运行在行组上，计算和返回单个值的函数。</p><p><strong>表12-1 SQL聚集函数</strong></p><table><thead><tr><th align="center">函 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center"><code>AVG()</code></td><td align="center">返回某列的平均值</td></tr><tr><td align="center"><code>COUNT()</code></td><td align="center">返回某列的行数</td></tr><tr><td align="center"><code>MAX()</code></td><td align="center">返回某列的最大值</td></tr><tr><td align="center"><code>MIN()</code></td><td align="center">返回某列的最小值</td></tr><tr><td align="center"><code>SUM()</code></td><td align="center">返回某列值之和</td></tr></tbody></table><p><code>COUNT()</code> 函数有两种使用方式。</p><ul><li>使用<code>COUNT(*)</code> 对表中行的数目进行计数，不管表列中包含的是空值（<code>NULL</code> ）还是非空值。</li><li>使用<code>COUNT(column)</code> 对特定列中具有值的行进行计数，忽略<code>NULL</code> 值。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">为description添加一条数据再执行下面两句</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> student;</span><br><span class="line">#</span><br><span class="line"><span class="number">9</span>条</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(`description`)</span><br><span class="line"><span class="keyword">from</span> student;</span><br><span class="line">#</span><br><span class="line"><span class="number">1</span>条</span><br></pre></td></tr></table></figure><hr><p><code>MAX()</code> 返回指定列中的最大值。<code>MAX()</code> 要求指定列名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">max</span>(id) <span class="keyword">as</span> max_id</span><br><span class="line"><span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><p><strong>对非数值数据使用<code>MAX()</code></strong></p><p>虽然<code>MAX()</code><br>一般用来找出最大的数值或日期值，但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在用于文本数据时，如果数据按相应的列排序，则<code>MAX()</code><br>返回最后一行。</p><p><code>SUM()</code> 用来返回指定列值的和（总计）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(id <span class="operator">*</span> student_number) <span class="keyword">AS</span> score</span><br><span class="line"><span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><blockquote><p><strong>在多个列上进行计算</strong>：利用标准的算术操作符，所有聚集函数都可用来执行多个列上的计算。</p></blockquote><p><strong>NULL值</strong></p><ul><li><p><code>AVG()</code> 函数忽略列值为<code>NULL</code> 的行。</p></li><li><p><code>MAX()</code> 函数忽略列值为<code>NULL</code> 的行。</p></li><li><p><code>MIN()</code> 函数忽略列值为<code>NULL</code> 的行。</p></li><li><p><code>SUM()</code> 函数忽略列值为<code>NULL</code> 的行。</p></li><li><p>如果指定列名，则指定列的值为空的行被<code>COUNT()</code> 函数忽略，但如果<code>COUNT()</code> 函数中用的是星号（<code>*</code> ），则不忽略。</p></li></ul><hr><h3 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h3><p>以上5个聚集函数都可以如下使用：</p><ul><li>对所有的行执行计算，指定<code>ALL</code> 参数或不给参数（因为<code>ALL</code> 是默认行为）；</li><li>只包含不同的值，指定<code>DISTINCT</code> 参数。</li></ul><p><strong><code>ALL</code> 为默认</strong></p><p><code>ALL</code> 参数不需要指定，因为它是默认行为。如果不指定<code>DISTINCT</code> ，则假定为<code>ALL</code> 。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(`tuition`) <span class="keyword">AS</span> avg_tuition</span><br><span class="line"><span class="keyword">FROM</span> `admission_info`;</span><br><span class="line">#</span><br><span class="line"><span class="number">110.110000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> `tuition`) <span class="keyword">AS</span> avg_tuition</span><br><span class="line"><span class="keyword">FROM</span> `admission_info`;</span><br><span class="line">#</span><br><span class="line"><span class="number">123.443333</span></span><br></pre></td></tr></table></figure><p>可以看到，在使用了<code>DISTINCT</code> 后，此例子中的<code>avg_tuition</code> 比较高，因为有多个物品具有相同的较低价格。排除它们提升了平均价格。</p><p><strong>注意</strong></p><p>如果指定列名，则<code>DISTINCT</code> 只能用于<code>COUNT()</code> 。<code>DISTINCT</code> 不能用于<code>COUNT(*)</code> ，因此不允许使用<code>COUNT（DISTINCT）</code> ，否则会产生错误。</p><p>类似地，<code>DISTINCT</code> 必须使用列名，不能用于计算或表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> `tuition`) <span class="keyword">AS</span> count_tuition</span><br><span class="line"><span class="keyword">FROM</span> `admission_info`;</span><br></pre></td></tr></table></figure><p><strong>将<code>DISTINCT</code> 用于<code>MIN()</code> 和<code>MAX()</code></strong></p><p>虽然<code>DISTINCT</code> 从技术上可用于<code>MIN()</code> 和<code>MAX()</code>，但这样做实际上没有价值。一个列中的最小值和最大值不管是否包含不同值都是相同的。</p><h3 id="组合聚集函数"><a href="#组合聚集函数" class="headerlink" title="组合聚集函数"></a>组合聚集函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(`tuition`)            <span class="keyword">AS</span> avg_tuition,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> `tuition`) <span class="keyword">AS</span> count_tuition</span><br><span class="line"><span class="keyword">FROM</span> `admission_info`;</span><br></pre></td></tr></table></figure><hr><h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><p>数据准备</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `goods`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `goods`</span><br><span class="line">(</span><br><span class="line">    `id`          <span class="type">bigint</span>(<span class="number">0</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">    `goods_name`  <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>,</span><br><span class="line">    `supplier`    <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;供货商&#x27;</span>,</span><br><span class="line">    `category_id` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品种类&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY           `key_category_id` (`category_id`) <span class="keyword">USING</span> BTREE COMMENT <span class="string">&#x27;分类id索引&#x27;</span></span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of goods</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `goods`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;拖鞋&#x27;</span>, <span class="string">&#x27;网易优选&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `goods`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;卫衣&#x27;</span>, <span class="string">&#x27;淘宝&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `goods`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;羽绒服&#x27;</span>, <span class="string">&#x27;天猫&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `goods`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;卫龙&#x27;</span>, <span class="string">&#x27;美团&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `category`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `category`</span><br><span class="line">(</span><br><span class="line">    `id`            <span class="type">bigint</span>(<span class="number">0</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">    `category_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类名称&#x27;</span>,</span><br><span class="line">    `category_desc` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类描述&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of category</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `category`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;鞋&#x27;</span>, <span class="string">&#x27;运动&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `category`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;衣服&#x27;</span>, <span class="string">&#x27;保暖&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `category`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;零食&#x27;</span>, <span class="string">&#x27;嘎嘎香&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h3><p>分组是在<code>SELECT</code> 语句的<code>GROUP BY</code> 子句中建立的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> category_id,</span><br><span class="line">       <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> count_category</span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category_id</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1	1</span><br><span class="line">2	2</span><br><span class="line">3	1</span><br></pre></td></tr></table></figure><ul><li>按照姓氏分组</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(`name`, <span class="number">1</span>, <span class="number">1</span>) <span class="keyword">AS</span> first_name,</span><br><span class="line">       <span class="built_in">count</span>(<span class="operator">*</span>)                <span class="keyword">AS</span> count_name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> first_name;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">张  <span class="number">1</span></span><br><span class="line">李	<span class="number">1</span></span><br><span class="line">王	<span class="number">2</span></span><br><span class="line">赵	<span class="number">1</span></span><br><span class="line">付	<span class="number">4</span></span><br></pre></td></tr></table></figure><p><code>GROUP BY</code> 子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集。</p><p>在具体使用<code>GROUP BY</code> 子句前，需要知道一些重要的规定。</p><ul><li><code>GROUP BY</code> 子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。</li><li>如果在<code>GROUP BY</code> 子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li><li><code>GROUP BY</code> 子句中列出的每个列都必须是检索列或有效的表达式（<strong>但不能是聚集函数</strong>）。如果在<code>SELECT</code><br>中使用表达式，则必须在<code>GROUP BY</code> 子句中指定相同的表达式。不能使用别名。</li><li>除聚集计算语句外，<code>SELECT</code> 语句中的每个列都必须在<code>GROUP BY</code> 子句中给出。</li><li>如果分组列中具有<code>NULL</code> 值，则<code>NULL</code> 将作为一个分组返回。如果列中有多行<code>NULL</code>值，它们将分为一组。</li><li><code>GROUP BY</code> 子句必须出现在<code>WHERE</code> 子句之后，<code>ORDER BY</code> 子句之前。</li></ul><p><strong>使用<code>ROLLUP</code></strong></p><p>使用<code>WITH ROLLUP</code> 关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> category_id,</span><br><span class="line">       <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> count_category</span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span></span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	1</span><br><span class="line">2	2</span><br><span class="line">3	1</span><br><span class="line">null	4</span><br></pre></td></tr></table></figure><h3 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h3><p><code>HAVING</code> 非常类似于<code>WHERE</code> 。事实上，目前为止所学过的所有类型的<code>WHERE</code> 子句都可以用<code>HAVING</code> 来替代。唯一的差别是<code>WHERE</code><br>过滤行，而<code>HAVING</code> 过滤分组。</p><p><strong><code>HAVING</code> 和<code>WHERE</code> 的差别</strong></p><p>这里有另一种理解方法，<code>WHERE</code> 在数据分组前进行过滤，<code>HAVING</code> 在数据分组后进行过滤。这是一个重要的区别，<code>WHERE</code><br>排除的行不包括在分组中。这可能会改变计算值，从而影响<code>HAVING</code> 子句中基于这些值过滤掉的分组。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> category_id,</span><br><span class="line">       <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> count_category</span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category_id</span><br><span class="line"><span class="keyword">HAVING</span> category_id <span class="operator">&gt;</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">demo <span class="number">2</span></span><br><span class="line"><span class="keyword">SELECT</span> category_id,</span><br><span class="line">       <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> count_category</span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category_id # 不可使用别名</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    count_category</span><br><span class="line">     <span class="operator">&gt;</span> <span class="number">1</span>;</span><br><span class="line">#</span><br><span class="line">可以使用别名</span><br></pre></td></tr></table></figure><blockquote><p>HAVING的条件只可能使用选择列或表达式列，包括聚集函数（select后面的）</p></blockquote><p><strong><code>HAVING</code> 和<code>WHERE</code>组合</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> category_id,</span><br><span class="line">       <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> count_category</span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&lt;</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category_id</span><br><span class="line"><span class="keyword">HAVING</span> category_id <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h3><p>虽然<code>GROUP BY</code> 和<code>ORDER BY</code> 经常完成相同的工作，但它们是非常不同的。</p><p><strong><code>ORDER BY</code> 与<code>GROUP BY</code></strong></p><table><thead><tr><th align="center"><code>ORDER BY</code></th><th align="center"><code>GROUP BY</code></th></tr></thead><tbody><tr><td align="center">排序产生的输出</td><td align="center">分组行。但输出可能不是分组的顺序</td></tr><tr><td align="center">任意列都可以使用（甚至非选择的列也可以使用）</td><td align="center">只可能使用选择列或表达式列，而且必须使用每个选择列表达式</td></tr><tr><td align="center">不一定需要</td><td align="center">如果与聚集函数一起使用列（或表达式），则必须使用</td></tr></tbody></table><p><strong>不要忘记<code>ORDER BY</code></strong></p><p>一般在使用<code>GROUP BY</code> 子句时，应该也给出<code>ORDER BY</code> 子句。这是保证数据正确排序的唯一方法。千万不要仅依赖<code>GROUP BY</code> 排序数据。</p><p>我们经常发现用<code>GROUP BY</code><br>分组的数据确实是以分组顺序输出的。但情况并不总是这样，它并不是SQL规范所要求的。此外，用户也可能会要求以不同于分组的顺序排序。仅因为你以某种方式分组数据（获得特定的分组聚集值），并不表示你需要以相同的方式排序输出。应该提供明确的<code>ORDER BY</code><br>子句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(`name`, <span class="number">1</span>, <span class="number">1</span>) <span class="keyword">AS</span> first_name,</span><br><span class="line">       <span class="built_in">count</span>(<span class="operator">*</span>)                <span class="keyword">AS</span> count_name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> first_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> count_name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">付	4</span><br><span class="line">王	2</span><br><span class="line">张	1</span><br><span class="line">李	1</span><br><span class="line">赵	1</span><br></pre></td></tr></table></figure><h3 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h3><p><strong><code>SELECT</code> 子句及其顺序</strong></p><table><thead><tr><th align="center">子 句</th><th align="center">说 明</th><th align="center">是否必须使用</th></tr></thead><tbody><tr><td align="center"><code>SELECT</code></td><td align="center">要返回的列或表达式</td><td align="center">是</td></tr><tr><td align="center"><code>FROM</code></td><td align="center">从中检索数据的表</td><td align="center">仅在从表选择数据时使用</td></tr><tr><td align="center"><code>WHERE</code></td><td align="center">行级过滤</td><td align="center">否</td></tr><tr><td align="center"><code>GROUP BY</code></td><td align="center">分组说明</td><td align="center">仅在按组计算聚集时使用</td></tr><tr><td align="center"><code>HAVING</code></td><td align="center">组级过滤</td><td align="center">否</td></tr><tr><td align="center"><code>ORDER BY</code></td><td align="center">输出排序顺序</td><td align="center">否</td></tr><tr><td align="center"><code>LIMIT</code></td><td align="center">要检索的行数</td><td align="center">否</td></tr></tbody></table><p><strong>SQL语句执行顺序</strong>: <strong>FROM、ON 、JOIN、WHERE、GROUP BY、AGG_FUNC、WITH、HAVING、SELECT、UNION、DISTINCT 、ORDER BY、LIMIT。</strong></p><hr><h2 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> goods_name,</span><br><span class="line">       supplier</span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">WHERE</span> supplier <span class="keyword">IN</span> (<span class="keyword">SELECT</span> supplier</span><br><span class="line">                   <span class="keyword">FROM</span> goods</span><br><span class="line">                   <span class="keyword">WHERE</span> category_id <span class="operator">=</span> <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>列必须匹配</strong></p><p>在<code>WHERE</code> 子句中使用子查询（如这里所示），应该保证<code>SELECT</code>语句具有与<code>WHERE</code> 子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。</p><p>虽然子查询一般与<code>IN</code> 操作符结合使用，但也可以用于测试等于（<code>=</code> ）、不等于（<code>&lt;</code>）等。</p><h3 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, (<span class="keyword">SELECT</span> category_desc <span class="keyword">FROM</span> category <span class="keyword">WHERE</span> category.id <span class="operator">=</span> goods.category_id) <span class="keyword">AS</span> category_desc</span><br><span class="line"><span class="keyword">FROM</span> goods;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	拖鞋	  网易优选	1	运动</span><br><span class="line">2	卫衣	  淘宝	 2	 保暖</span><br><span class="line">3	羽绒服	  天猫     2	保暖</span><br><span class="line">4	卫龙	  美团	 3	 嘎嘎香</span><br></pre></td></tr></table></figure><p><strong>逐渐增加子查询来建立查询</strong></p><p>用子查询测试和调试查询很有技巧性，特别是在这些语句的复杂性不断增加的情况下更是如此。用子查询建立（和测试）查询的最可靠的方法是逐渐进行，这与MySQL处理它们的方法非常相同。</p><p>首先，建立和测试最内层的查询。然后，用硬编码数据建立和测试外层查询，并且仅在确认它正常后才嵌入子查询。这时，再次测试它。对于要增加的每个查询，重复这些步骤。这样做仅给构造查询增加了一点点时间，但节省了以后（找出查询为什么不正常）的大量时间，并且极大地提高了查询一开始就正常工作的可能性。</p><hr><h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><p>SQL最强大的功能之一就是能在数据检索查询的执行中联结（join）表。</p><p><strong>外键（foreignkey）</strong></p><p>外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p><p>这样做的好处如下：</p><ul><li>信息不重复，从而不浪费时间和空间；</li><li>如果信息变动，可以只更新某个表中的单个记录，相关表中的数据不用改动；</li><li>由于数据无重复，显然数据是一致的，这使得处理数据更简单。</li></ul><p>总之，关系数据可以有效地存储和方便地处理。因此，关系数据库的可伸缩性远比非关系数据库要好。</p><p><strong>可伸缩性（scale）</strong></p><p>能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为<em>可伸缩性好</em> （scale well)。</p><h3 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> goods_name,</span><br><span class="line">       category_desc</span><br><span class="line"><span class="keyword">FROM</span> goods,</span><br><span class="line">     category</span><br><span class="line"><span class="keyword">WHERE</span> category.id <span class="operator">=</span> goods.category_id;</span><br></pre></td></tr></table></figure><p><strong>完全限定列名</strong></p><p>在引用的列可能出现二义性时，必须使用完全限定列名（用一个点分隔的表名和列名）。如果引用一个没有用表名限制的具有二义性的列名，MySQL将返回错误。</p><h4 id="WHERE-子句的重要性"><a href="#WHERE-子句的重要性" class="headerlink" title="WHERE 子句的重要性"></a><strong><code>WHERE</code> 子句的重要性</strong></h4><p>将第一个表中的每一行与第二个表中的每一行配对。<code>WHERE</code><br>子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行。没有<code>WHERE</code> 子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。</p><h4 id="笛卡儿积（cartesianproduct）"><a href="#笛卡儿积（cartesianproduct）" class="headerlink" title="笛卡儿积（cartesianproduct）"></a><strong>笛卡儿积（cartesianproduct）</strong></h4><p>由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> goods_name,</span><br><span class="line">       category_desc</span><br><span class="line"><span class="keyword">FROM</span> goods,</span><br><span class="line">     category;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">拖鞋	嘎嘎香</span><br><span class="line">拖鞋	保暖</span><br><span class="line">拖鞋	运动</span><br><span class="line">卫衣	嘎嘎香</span><br><span class="line">卫衣	保暖</span><br><span class="line">卫衣	运动</span><br><span class="line">羽绒服	嘎嘎香</span><br><span class="line">羽绒服	保暖</span><br><span class="line">羽绒服	运动</span><br><span class="line">卫龙	嘎嘎香</span><br><span class="line">卫龙	保暖</span><br><span class="line">卫龙	运动</span><br></pre></td></tr></table></figure><h3 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a><strong>内部联结</strong></h3><p>目前为止所用的联结称为<em>等值联结</em> （equijoin），它基于两个表之间的相等测试。这种联结也称为内部联结。其实，对于这种联结可以使用稍微不同的语法来明确指定联结的类型。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> goods_name,</span><br><span class="line">       category_desc</span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line">         <span class="keyword">INNER</span> <span class="keyword">JOIN</span> category <span class="keyword">ON</span> category.id <span class="operator">=</span> goods.category_id;    </span><br></pre></td></tr></table></figure><h3 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a><strong>联结多个表</strong></h3><p>QL对一条<code>SELECT</code> 语句中可以联结的表的数目没有限制。创建联结的基本规则也相同。首先列出所有表，然后定义表之间的关系。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> goods_name,</span><br><span class="line">       category_desc</span><br><span class="line"><span class="keyword">FROM</span> goods,</span><br><span class="line">     category, ...</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>性能考虑</strong></p><p>MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害。</p><p><strong>多做实验</strong></p><p>正如所见，为执行任一给定的SQL操作，一般存在不止一种方法。很少有绝对正确或绝对错误的方法。性能可能会受操作类型、表中数据量、是否存在索引或键以及其他一些条件的影响。因此，有必要对不同的选择机制进行实验，以找出最适合具体情况的方法。</p><hr><h2 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h2><h3 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h3><p>表别名不仅能用于<code>WHERE</code> 子句，它还可以用于<code>SELECT</code> 的列表、<code>ORDER BY</code> 子句以及语句的其他部分。应该注意，表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户机。</p><h3 id="使用不同类型的联结"><a href="#使用不同类型的联结" class="headerlink" title="使用不同类型的联结"></a>使用不同类型的联结</h3><h4 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a><strong>自联结</strong></h4><p>之前案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> goods_name,</span><br><span class="line">       supplier</span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">WHERE</span> supplier <span class="keyword">IN</span> (<span class="keyword">SELECT</span> supplier</span><br><span class="line">                   <span class="keyword">FROM</span> goods</span><br><span class="line">                   <span class="keyword">WHERE</span> category_id <span class="operator">=</span> <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>自联结写法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> g1.goods_name,</span><br><span class="line">       g1.supplier,</span><br><span class="line">       g1.category_id</span><br><span class="line"><span class="keyword">FROM</span> goods <span class="keyword">AS</span> g1,</span><br><span class="line">     goods <span class="keyword">AS</span> g2</span><br><span class="line"><span class="keyword">WHERE</span> g1.supplier <span class="operator">=</span> g2.supplier</span><br><span class="line">  <span class="keyword">AND</span> g2.category_id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>用自联结而不用子查询</strong></p><p>自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候处理联结远比处理子查询快得多。应该试一下两种方法，以确定哪一种的性能更好。</p><h4 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a><strong>自然联结</strong></h4><p><em>自然联结</em> 排除多次出现，使每个列只返回一次。怎样完成这项工作呢？答案是，系统不完成这项工作，由你自己完成它。</p><p>自然联结是这样一种联结，其中你只能选择那些唯一的列。这一般是通过对表使用通配符（<code>SELECT*</code> ），对所有其他表的列使用明确的子集来完成的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> g.<span class="operator">*</span>,</span><br><span class="line">       c.category_desc</span><br><span class="line"><span class="keyword">FROM</span> goods <span class="keyword">AS</span> g,</span><br><span class="line">     category <span class="keyword">AS</span> c</span><br><span class="line"><span class="keyword">WHERE</span> g.category_id <span class="operator">=</span> c.id</span><br></pre></td></tr></table></figure><p>事实上，迄今为止我们建立的每个内部联结都是自然联结，很可能我们永远都不会用到不是自然联结的内部联结。</p><h4 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h4><p>与内部联结关联两个表中的行不同的是，外部联结还包括没有关联行的行。在使用<code>OUTER JOIN</code> 语法时，必须使用<code>RIGHT</code> 或<code>LEFT</code><br>关键字指定包括其所有行的表（<code>RIGHT</code> 指出的是<code>OUTER JOIN</code> 右边的表，而<code>LEFT</code> 指出的是<code>OUTER JOIN</code> 左边的表）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> goods_name,</span><br><span class="line">       category_desc</span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line">         <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> category <span class="keyword">ON</span> category.id <span class="operator">=</span> goods.category_id;</span><br></pre></td></tr></table></figure><p><strong>外部联结的类型</strong></p><p>存在两种基本的外部联结形式：左外部联结和右外部联结。它们之间的唯一差别是所关联的表的顺序不同。换句话说，左外部联结可通过颠倒<code>FROM</code><br>或<code>WHERE</code> 子句中表的顺序转换为右外部联结。因此，两种类型的外部联结可互换使用，而究竟使用哪一种纯粹是根据方便而定。</p><p><strong>没有<code>*=</code> 操作符</strong></p><p>MySQL不支持简化字符<code>*=</code> 和<code>=*</code> 的使用，这两种操作符在其他DBMS中是很流行的。</p><hr><h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>多数SQL查询都只包含从一个或多个表中返回数据的单条<code>SELECT</code> 语句。MySQL也允许执行多个查询（多条<code>SELECT</code><br>语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compoundquery）。</p><p>有两种基本情况，其中需要使用组合查询：</p><ul><li>在单个查询中从不同的表返回类似结构的数据；</li><li>对单个表执行多个查询，按单个查询返回数据。</li></ul><p><strong>组合查询和多个<code>WHERE</code> 条件</strong></p><p>多数情况下，组合相同表的两个查询完成的工作与具有多个<code>WHERE</code> 子句条件的单条查询完成的工作相同。换句话说，任何具有多个<code>WHERE</code><br>子句的<code>SELECT</code> 语句都可以作为一个组合查询给出，在以下段落中可以看到这一点。这两种技术在不同的查询中性能也不同。因此，应该试一下这两种技术，以确定对特定的查询哪一种性能更好。</p><h3 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h3><h4 id="使用UNION"><a href="#使用UNION" class="headerlink" title="使用UNION"></a><strong>使用<code>UNION</code></strong></h4><p><code>UNION</code> 的使用很简单。所需做的只是给出每条<code>SELECT</code> 语句，在各条语句之间放上关键字<code>UNION</code> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">WHERE</span> category_id <span class="operator">&lt;</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><code>UNION</code> 从查询结果集中自动去除了重复的行（换句话说，它的行为与单条<code>SELECT</code> 语句中使用多个<code>WHERE</code> 子句条件一样）。</p><p>在使用<code>UNION</code> 时，重复的行被自动取消。这是<code>UNION</code><br>的默认行为，但是如果需要，可以改变它。事实上，如果想返回所有匹配行，可使用<code>UNION ALL</code> 而不是<code>UNION</code> 。</p><p>有几条规则需要注意</p><ul><li><code>UNION</code> 必须由两条或两条以上的<code>SELECT</code> 语句组成，语句之间用关键字<code>UNION</code>分隔（因此，如果组合4条<code>SELECT</code><br>语句，将要使用3个<code>UNION</code> 关键字）。</li><li><code>UNION</code> 中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。</li><li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</li></ul><p><strong><code>NION</code> 与<code>WHERE</code></strong></p><p><code>UNION</code> 几乎总是完成与多个<code>WHERE</code> 条件相同的工作。<code>UNION ALL</code> 为<code>UNION</code> 的一种形式，它完成<code>WHERE</code><br>子句完成不了的工作。如果确实需要每个条件的匹配行全部出现（包括重复行），则必须使用<code>UNION ALL</code> 而不是<code>WHERE</code> 。</p><h3 id="对组合查询结果排序"><a href="#对组合查询结果排序" class="headerlink" title="对组合查询结果排序"></a><strong>对组合查询结果排序</strong></h3><p><code>SELECT</code> 语句的输出用<code>ORDER BY</code> 子句排序。在用<code>UNION</code> 组合查询时，只能使用一条<code>ORDER BY</code> 子句，它必须出现在最后一条<code>SELECT</code><br>语句之后。</p><p>对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条<code>ORDER BY</code> 子句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">WHERE</span> category_id <span class="operator">&lt;</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br></pre></td></tr></table></figure><hr><h2 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a><strong>全文本搜索</strong></h2><h3 id="并非所有引擎都支持全文本搜索"><a href="#并非所有引擎都支持全文本搜索" class="headerlink" title="并非所有引擎都支持全文本搜索"></a><strong>并非所有引擎都支持全文本搜索</strong></h3><p>MySQL支持几种基本的数据库引擎。并非所有的引擎都支持本书所描述的全文本搜索。两个最常使用的引擎为<code>MyISAM</code> 和<code>InnoDB</code><br>，前者支持全文本搜索，而后者不支持。</p><ul><li><p><code>LIKE</code> 关键字，它利用通配操作符匹配文本（和部分文本）。使用<code>LIKE</code>，能够查找包含特殊值或部分值的行（不管这些值位于列内什么位置）。</p></li><li><p>使用正则表达式，可以编写查找所需行的非常复杂的匹配模式。</p></li></ul><p>虽然这些搜索机制非常有用，但存在几个重要的限制。</p><ul><li>性能：通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行（而且这些搜索极少使用表索引）。因此，由于被搜索行数不断增加，这些搜索可能非常耗时。</li><li>明确控制：使用通配符和正则表达式匹配，很难（而且并不总是能）明确地控制匹配什么和不匹配什么。例如，指定一个词必须匹配，一个词必须不匹配，而一个词仅在第一个词确实匹配的情况下才可以匹配或者才可以不匹配。</li><li>智能化的结果：虽然基于通配符和正则表达式的搜索提供了非常灵活的搜索，但它们都不能提供一种智能化的选择结果的方法。例如，一个特殊词的搜索将会返回包含该词的所有行，而不区分包含单个匹配的行和包含多个匹配的行（按照可能是更好的匹配来排列它们）。类似，一个特殊词的搜索将不会找出不包含该词但包含其他相关词的行。</li></ul><p>所有这些限制以及更多的限制都可以用全文本搜索来解决。在使用全文本搜索时，MySQL不需要分别查看每个行，不需要分别分析和处理每个词。MySQL创建指定列中各词的一个索引，搜索可以针对这些词进行。这样，MySQL可以快速有效地决定哪些词匹配（哪些行包含它们），哪些词不匹配，它们匹配的频率，等等。</p><blockquote><p>未完待续。。。</p></blockquote><hr><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p><code>INSERT</code> 是用来插入（或添加）行到数据库表的。插入可以用几种方式使用：</p><ul><li>插入完整的行；</li><li>插入行的一部分；</li><li>插入多行；</li><li>插入某些查询的结果。</li></ul><p><strong>插入及系统安全</strong></p><p>可针对每个表或每个用户，利用MySQL的安全机制禁止使用<code>INSERT</code> 语句。</p><h3 id="插入完整的行"><a href="#插入完整的行" class="headerlink" title="插入完整的行"></a>插入完整的行</h3><p>简单写法【不推荐】</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> news</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="keyword">NULL</span>,</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure><p>各个列必须以它们在表定义中出现的次序填充。第一列<code>id</code> 也为<code>NULL</code><br>。这是因为每次插入一个新行时，该列由MySQL自动增量。你不想给出一个值（这是MySQL的工作），又不能省略此列（如前所述，必须给出每个列），所以指定一个<code>NULL</code><br>值（它被MySQL忽略，MySQL在这里插入下一个可用的<code>id</code> 值）</p><p>推荐写法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> news (news_title, news_desc)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;d&#x27;</span>)</span><br></pre></td></tr></table></figure><p>因为提供了列名，<code>VALUES</code> 必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序。</p><p>其优点是，即使表的结构改变，此<code>INSERT</code> 语句仍然能正确工作。你会发现<code>id</code> 的<code>NULL</code> 值是不必要的，<code>id</code> 列并没有出现在列表中，所以不需要任何值。</p><p><strong>总是使用列的列表</strong></p><p>一般不要使用没有明确给出列的列表的<code>INSERT</code> 语句。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化。</p><p><strong>仔细地给出值</strong></p><p>不管使用哪种<code>INSERT</code> 语法，都必须给出<code>VALUES</code><br>的正确数目。如果不提供列名，则必须给每个表列提供一个值。如果提供列名，则必须对每个列出的列给出一个值。如果不这样，将产生一条错误消息，相应的行插入不成功。</p><p><strong>省略列</strong> 如果表的定义允许，则可以在INSERT操作中省略某些列。省略的列必须满足以下某个条件。</p><ul><li>该列定义为允许<code>NULL</code> 值（无值或空值）。</li><li>在表定义中给出默认值。这表示如果不给出值，将使用默认值。</li></ul><p>如果对表中不允许<code>NULL</code> 值且没有默认值的列不给出值，则MySQL将产生一条错误消息，并且相应的行插入不成功。</p><h3 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h3><p>可以使用多条<code>INSERT</code> 语句，甚至一次提交它们，每条语句用一个分号结束。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> news (news_title, news_desc)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> news (news_title, news_desc)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;e&#x27;</span>);</span><br></pre></td></tr></table></figure><p>或者，只要每条<code>INSERT</code> 语句中的列名（和次序）相同，可以如下组合各语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> news (news_title, news_desc)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;f&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;f&#x27;</span>);</span><br></pre></td></tr></table></figure><p>其中单条<code>INSERT</code> 语句有多组值，每组值用一对圆括号括起来，用逗号分隔。</p><p><strong>提高INSERT的性能</strong>：此技术可以提高数据库处理的性能，因为MySQL用单条<code>INSERT</code> 语句处理多个插入比使用多条<code>INSERT</code> 语句快。</p><h3 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h3><p><code>INSERT SELECT</code> ，顾名思义，它是由一条<code>INSERT</code> 语句和一条<code>SELECT</code> 语句组成的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> news (news_title, news_desc)</span><br><span class="line"><span class="keyword">SELECT</span> news_title,</span><br><span class="line">       news_desc</span><br><span class="line"><span class="keyword">FROM</span> news</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="INSERT-SELECT-中的列名"><a href="#INSERT-SELECT-中的列名" class="headerlink" title="INSERT SELECT 中的列名"></a><strong><code>INSERT SELECT</code> 中的列名</strong></h4><p>为简单起见，这个例子在<code>INSERT</code> 和<code>SELECT</code> 语句中使用了相同的列名。但是，不一定要求列名匹配。</p><p>事实上，MySQL甚至不关心<code>SELECT</code> 返回的列名。它使用的是列的位置，因此<code>SELECT</code><br>中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等。这对于从使用不同列名的表中导入数据是非常有用的。</p><p><code>INSERT SELECT</code> 中<code>SELECT</code> 语句可包含<code>WHERE</code> 子句以过滤插入的数据。</p><h2 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h2><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>为了更新（修改）表中的数据，可使用<code>UPDATE</code> 语句。可采用两种方式使用<code>UPDATE</code>：</p><ul><li>更新表中特定行；</li><li>更新表中所有行。</li></ul><p>基本的<code>UPDATE</code> 语句由3部分组成，分别是：</p><ul><li>要更新的表；</li><li>列名和它们的新值；</li><li>确定要更新行的过滤条件。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> news</span><br><span class="line"><span class="keyword">SET</span> news_title <span class="operator">=</span> <span class="string">&#x27;d&#x27;</span>,</span><br><span class="line">    news_desc  <span class="operator">=</span> <span class="string">&#x27;d&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">11</span>;</span><br></pre></td></tr></table></figure><p><strong>在<code>UPDATE</code> 语句中使用子查询</strong></p><p><code>UPDATE</code> 语句中可以使用子查询，使得能用<code>SELECT</code> 语句检索出的数据更新列数据。</p><p><strong><code>IGNORE</code> 关键字</strong></p><p>如果用<code>UPDATE</code> 语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个<code>UPDATE</code><br>操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用<code>IGNORE</code>关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> IGNORE news ... </span><br></pre></td></tr></table></figure><p>为了删除某个列的值，可设置它为<code>NULL</code> （假如表定义允许<code>NULL</code> 值）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> news</span><br><span class="line">    news_desc <span class="operator">=</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    id <span class="operator">=</span> <span class="number">11</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a><strong>删除数据</strong></h3><p>为了从一个表中删除（去掉）数据，使用<code>DELETE</code> 语句。可以两种方式使用<code>DELETE</code>：</p><ul><li>从表中删除特定的行；</li><li>从表中删除所有行。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> news</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>更快的删除</strong></p><p>如果想从表中删除所有行，不要使用<code>DELETE</code> 。可使用<code>TRUNCATE TABLE</code> 语句，它完成相同的工作，但速度更快（<code>TRUNCATE</code><br>实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）[<strong>慎用</strong>]</p><p>使用<code>UPDATE</code> 或<code>DELETE</code> 时应遵循的习惯。</p><ul><li>除非确实打算更新和删除每一行，否则绝对不要使用不带<code>WHERE</code> 子句的<code>UPDATE</code> 或<code>DELETE</code> 语句。</li><li>保证每个表都有主键，尽可能像<code>WHERE</code>子句那样使用它（可以指定各主键、多个值或值的范围）。</li><li>在对<code>UPDATE</code> 或<code>DELETE</code> 语句使用<code>WHERE</code> 子句前，应该先用<code>SELECT</code> 进行测试，保证它过滤的是正确的记录，以防编写的<code>WHERE</code><br>子句不正确。</li><li>使用强制实施引用完整性的数据库，这样MySQL将不允许删除具有与其他表相关联的数据的行。【在程序中应使用物理外键】</li></ul><h2 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a><strong>创建表</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `words`</span><br><span class="line">(</span><br><span class="line">    `id`          <span class="type">bigint</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id (自增)&#x27;</span>,</span><br><span class="line">    `word`        <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;单词&#x27;</span>,</span><br><span class="line">    `description` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;介绍&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci COMMENT <span class="string">&#x27;单词表&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="使用NULL-值"><a href="#使用NULL-值" class="headerlink" title="使用NULL 值"></a><strong>使用<code>NULL</code> 值</strong></h4><p><strong>理解<code>NULL</code></strong> 不要把<code>NULL</code> 值与空串相混淆。<code>NULL</code> 值是没有值，它不是空串。如果指定’’<br>（两个单引号，其间没有字符），这在<code>NOT NULL</code> 列中是允许的。空串是一个有效的值，它不是无值。<code>NULL</code> 值用关键字<code>NULL</code> 而不是空串指定。</p><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a><strong>主键</strong></h4><p>主键值必须唯一。即，表中的每个行必须具有唯一的主键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。</p><p>主键为其值唯一标识表中每个行的列。主键中只能使用不允许<code>NULL</code> 值的列。允许<code>NULL</code> 值的列不能作为唯一标识。</p><h4 id="使用AUTO-INCREMENT"><a href="#使用AUTO-INCREMENT" class="headerlink" title="使用AUTO_INCREMENT"></a><strong>使用<code>AUTO_INCREMENT</code></strong></h4><p><strong>覆盖<code>AUTO_INCREMENT</code></strong> 如果一个列被指定为<code>AUTO_INCREMENT</code> ，则它需要使用特殊的值吗？你可以简单地在<code>INSERT</code><br>语句中指定一个值，只要它是唯一的（至今尚未使用过）即可，该值将被用来替代自动生成的值。后续的增量将开始使用该手工插入的值。</p><p><strong>确定<code>AUTO_INCREMENT</code> 值</strong> 让MySQL生成（通过自动增量）主键的一个缺点是你不知道这些值都是谁。</p><h4 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a><strong>指定默认值</strong></h4><p>如果在插入行时没有给出值，MySQL允许指定此时使用的默认值。默认值用<code>CREATE TABLE</code> 语句的列定义中的DEFAULT关键字指定。</p><p><strong>不允许函数</strong> 与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量。</p><h4 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a><strong>引擎类型</strong></h4><p>为什么要发行多种引擎呢？因为它们具有各自不同的功能和特性，为不同的任务选择正确的引擎能获得良好的功能和灵活性。</p><p>以下是几个需要知道的引擎：</p><ul><li><code>InnoDB</code> 是一个可靠的事务处理引擎，它不支持全文本搜索；</li><li><code>MEMORY</code> 在功能等同于<code>MyISAM</code> ，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）；</li><li><code>MyISAM</code> 是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理。</li></ul><p><strong>外键不能跨引擎</strong></p><p>引擎类型可以混用。但混用引擎类型有一个大缺陷。外键（用于强制实施引用完整性）不能跨引擎，即使用一个引擎的表不能引用具有使用不同引擎的表的外键。</p><h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3><p>使用<code>ALTER TABLE</code> 更改表结构，必须给出下面的信息：</p><ul><li>在<code>ALTER TABLE</code> 之后给出要更改的表名（该表必须存在，否则将出错）；</li><li>所做更改的列表。</li></ul><p>给表添加一个列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> words</span><br><span class="line">    <span class="keyword">ADD</span> mark <span class="type">varchar</span>(<span class="number">225</span>);</span><br></pre></td></tr></table></figure><p>定义外键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> words</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_student_id <span class="keyword">FOREIGN</span> KEY (id) <span class="keyword">REFERENCES</span> student (id);</span><br></pre></td></tr></table></figure><p><strong>小心使用<code>ALTER TABLE</code></strong></p><p>使用<code>ALTER TABLE</code> 要极为小心，应该在进行改动前做一个完整的备份（模式和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的列，可能不能删除它们。类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。</p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>删除表没有确认，也不能撤销，执行这条语句将永久删除该表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> words;</span><br></pre></td></tr></table></figure><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RENAME</span><br><span class="line"><span class="keyword">TABLE</span> words <span class="keyword">TO</span> words2;</span><br></pre></td></tr></table></figure><p>对多个表重命名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RENAME</span><br><span class="line"><span class="keyword">TABLE</span> words <span class="keyword">TO</span> words2,</span><br><span class="line">             news <span class="keyword">TO</span> news2;</span><br></pre></td></tr></table></figure><hr><h2 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h2><p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p><p>作为视图，它不包含表中应该有的任何列或数据，它包含的是一个SQL查询。</p><p>在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图执行<code>SELECT</code> 操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据（添加和更新数据存在某些限制。</p><h3 id="常见的应用"><a href="#常见的应用" class="headerlink" title="常见的应用"></a>常见的应用</h3><ul><li>重用SQL语句。</li><li>简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</li><li>使用表的组成部分而不是整个表。</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul><p>视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a><strong>性能问题</strong></h3><p>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。</p><h3 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a><strong>视图的规则和限制</strong></h3><p>下面是关于视图创建和使用的一些最常见的规则和限制。</p><ul><li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</li><li>对于可以创建的视图数目没有限制。</li><li>为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</li><li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</li><li><code>ORDER BY</code> 可以用在视图中，但如果从该视图检索数据<code>SELECT</code> 中也含有<code>ORDER BY</code> ，那么该视图中的<code>ORDER BY</code> 将被覆盖。</li><li>视图不能索引，也不能有关联的触发器或默认值。</li><li>视图可以和表一起使用。例如，编写一条联结表和视图的<code>SELECT</code> 语句。</li></ul><h3 id="使用视图-1"><a href="#使用视图-1" class="headerlink" title="使用视图"></a>使用视图</h3><h4 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h4><ul><li>视图用<code>CREATE VIEW</code> 语句来创建。</li><li>使用<code>SHOW CREATE VIEW viewname;</code> 来查看创建视图的语句。</li><li>用<code>DROP</code> 删除视图，其语法为<code>DROP VIEW viewname;</code> 。</li><li>更新视图时，可以先用<code>DROP</code> 再用<code>CREATE</code> ，也可以直接用<code>CREATE OR REPLACE VIEW</code><br>。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</li></ul><h4 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a><strong>利用视图简化复杂的联结</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_goods_category <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> goods_name,</span><br><span class="line">       category_desc</span><br><span class="line"><span class="keyword">FROM</span> goods,</span><br><span class="line">     category</span><br><span class="line"><span class="keyword">WHERE</span> category.id <span class="operator">=</span> goods.category_id;</span><br></pre></td></tr></table></figure><p>尝试查询数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> goods_name,</span><br><span class="line">       category_desc</span><br><span class="line"><span class="keyword">FROM</span> v_goods_category</span><br><span class="line"><span class="keyword">WHERE</span> goods_name <span class="keyword">LIKE</span> <span class="string">&#x27;卫%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这条语句通过<code>WHERE</code> 子句从视图中检索特定数据。在MySQL处理此查询时，它将指定的<code>WHERE</code> 子句添加到视图查询中的已有<code>WHERE</code><br>子句中，以便正确过滤数据。</p><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">卫衣	保暖</span><br><span class="line">卫龙	嘎嘎香</span><br></pre></td></tr></table></figure><h4 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a><strong>用视图过滤不想要的数据</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_student_no_fu <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;付%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong><code>WHERE</code> 子句与<code>WHERE</code> 子句</strong> 如果从视图检索数据时使用了一条<code>WHERE</code> 子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。</p><h4 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a><strong>使用视图与计算字段</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_student_score <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       id <span class="operator">*</span> student_number <span class="keyword">AS</span> score</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;付%&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a><strong>更新视图</strong></h3><p>通常，视图是可更新的（即，可以对它们使用<code>INSERT</code> 、<code>UPDATE</code> 和<code>DELETE</code><br>）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行。</p><p>但是，并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p><ul><li>分组（使用<code>GROUP BY</code> 和<code>HAVING</code> ）；</li><li>联结；</li><li>子查询；</li><li>并；</li><li>聚集函数（<code>Min()</code> 、<code>Count()</code> 、<code>Sum()</code> 等）；</li><li><code>DISTINCT</code> ；</li><li>导出（计算）列。</li></ul><p><strong>可能的变动</strong> 上面列出的限制自MySQL5以来是正确的。不过，未来的MySQL很可能会取消某些限制。</p><p><strong>将视图用于检索</strong> 一般，应该将视图用于检索（<code>SELECT</code> 语句）而不用于更新（<code>INSERT</code> 、<code>UPDATE</code> 和<code>DELETE</code> )。</p><hr><h2 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h2><blockquote><p>未完待续。。。</p></blockquote><h2 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h2><blockquote><p>未完待续。。。</p></blockquote><h2 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h2><blockquote><p>未完待续。。。</p></blockquote><hr><h2 id="管理事务处理"><a href="#管理事务处理" class="headerlink" title="管理事务处理"></a>管理事务处理</h2><p>关于事务处理需要知道的几个术语：</p><ul><li><strong>事务（transaction）</strong> 指一组SQL语句；</li><li><strong>回退（rollback）</strong> 指撤销指定SQL语句的过程；</li><li><strong>提交（commit）</strong> 指将未存储的SQL语句结果写入数据库表；</li><li><strong>保留点（savepoint）</strong> 指事务处理中设置的临时占位符（place-holder），你可以对它发布回退（与回退整个事务处理不同）。</li></ul><p>标识事务的开始</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br></pre></td></tr></table></figure><p><code>ROLLBACK</code> 命令用来回退（撤销）MySQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">--- create</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_student_score <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> `name`,</span><br><span class="line">       id <span class="operator">*</span> student_number <span class="keyword">AS</span> score</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;付%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--- del</span></span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> news;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><blockquote><p><code>ROLLBACK</code> 只能在一个事务处理内使用（在执行一条<code>START TRANSACTION</code> 命令之后）。</p></blockquote><h3 id="哪些语句可以回退"><a href="#哪些语句可以回退" class="headerlink" title="哪些语句可以回退"></a><strong>哪些语句可以回退</strong></h3><p>事务处理用来管理<code>INSERT</code> 、<code>UPDATE</code> 和<code>DELETE</code> 语句。你不能回退<code>SELECT</code> 语句。（这样做也没有什么意义。）</p><p>你不能回退<code>CREATE</code> 或<code>DROP</code> 操作。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。</p><h3 id="使用COMMIT"><a href="#使用COMMIT" class="headerlink" title="使用COMMIT"></a><strong>使用<code>COMMIT</code></strong></h3><p>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交（implicitcommit），即提交（写或保存）操作是自动进行的。</p><p>但是，在事务处理块中，提交不会隐含地进行。为进行明确的提交，使用<code>COMMIT</code> 语句，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> `words`;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p><strong>隐含事务关闭</strong> 当<code>COMMIT</code> 或<code>ROLLBACK</code> 语句执行后，事务会自动关闭（将来的更改会隐含提交）。</p><h3 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a><strong>使用保留点</strong></h3><p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符。这样，如果需要回退，可以回退到某个占位符。这些占位符称为保留点。</p><p>每个保留点都取标识它的唯一名字，以便在回退时，MySQL知道要回退到何处。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete_news_before;</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> `news`;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete_words_before;</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> `words`;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete_words_before;</span><br></pre></td></tr></table></figure><p><strong>保留点越多越好</strong> 可以在MySQL代码中设置任意多的保留点，越多越好。为什么呢？因为保留点越多，你就越能按自己的意愿灵活地进行回退。</p><p><strong>释放保留点</strong> 保留点在事务处理完成（执行一条<code>ROLLBACK</code> 或<code>COMMIT</code> ）后自动释放。自MySQL 5以来，也可以用<code>RELEASE SAVEPOINT</code><br>明确地释放保留点。</p><hr><h3 id="更改默认的提交行为"><a href="#更改默认的提交行为" class="headerlink" title="更改默认的提交行为"></a><strong>更改默认的提交行为</strong></h3><p>默认的MySQL行为是自动提交所有更改。换句话说，任何时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span></span><br><span class="line">autocommit<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><code>autocommit</code> 标志决定是否自动提交更改，不管有没有<code>COMMIT</code> 语句。</p><p>设置<code>autocommit</code> 为<code>0</code> （假）指示MySQL不自动提交更改（直到<code>autocommit</code> 被设置为真为止）。</p><blockquote><p><strong>标志为连接专用</strong> <code>autocommit</code> 标志是针对每个连接而不是服务器的。</p></blockquote><hr><h2 id="全球化和本地化"><a href="#全球化和本地化" class="headerlink" title="全球化和本地化"></a>全球化和本地化</h2><p>数据库表被用来存储和检索数据。不同的语言和字符集需要以不同的方式存储和检索。因此，MySQL需要适应不同的字符集（不同的字母和字符），适应不同的排序和检索数据的方法。</p><p>在讨论多种语言和字符集时，将会遇到以下重要术语：</p><ul><li><strong>字符集</strong> 为字母和符号的集合；</li><li><strong>编码</strong> 为某个字符集成员的内部表示；</li><li><strong>校对</strong> 为规定字符如何比较的指令。</li></ul><p><strong>校对为什么重要</strong></p><p>排序英文正文很容易，对吗？或许不。考虑词APE、apex和Apple。它们处于正确的排序顺序吗？</p><p>这有赖于你是否想区分大小写。使用区分大小写的校对顺序，这些词有一种排序方式，使用不区分大小写的校对顺序有另外一种排序方式。这不仅影响排序（如用<code>ORDER BY</code><br>排序数据），还影响搜索（例如，寻找apple的<code>WHERE</code> 子句是否能找到APPLE）。</p><p>在使用诸如法文à或德文ö这样的字符时，情况更复杂，在使用不基于拉丁文的字符集（日文、希伯来文、俄文等）时，情况更为复杂。</p><p>在MySQL的正常数据库活动（<code>SELECT</code> 、<code>INSERT</code> 等）中，不需要操心太多的东西。使用何种字符集和校对的决定在服务器、数据库和表级进行。</p><h3 id="使用字符集和校对顺序"><a href="#使用字符集和校对顺序" class="headerlink" title="使用字符集和校对顺序"></a>使用字符集和校对顺序</h3><p>MySQL支持众多的字符集。为查看所支持的字符集完整列表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span></span><br><span class="line"><span class="type">CHARACTER</span> <span class="keyword">SET</span>;</span><br></pre></td></tr></table></figure><p>显示所有可用的字符集以及每个字符集的描述和默认校对。</p><p>查看所支持校对的完整列表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLLATION</span>;</span><br></pre></td></tr></table></figure><p>此语句显示所有可用的校对，以及它们适用的字符集。</p><p>可以看到有的字符集具有不止一种校对。例如，<code>latin1</code> 对不同的欧洲语言有几种校对，而且许多校对出现两次，一次区分大小写（由<code>_cs</code><br>表示），一次不区分大小写（由<code>_ci</code> 表示）。</p><p>通常系统管理在安装时定义一个默认的字符集和校对。此外，也可以在创建数据库时，指定默认的字符集和校对。</p><p>为了确定所用的字符集和校对，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span></span><br><span class="line">VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span></span><br><span class="line">VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>实际上，字符集很少是服务器范围（甚至数据库范围）的设置。不同的表，甚至不同的列都可能需要不同的字符集，而且两者都可以在创建表时指定。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `words`</span><br><span class="line">(</span><br><span class="line">    `id`          <span class="type">bigint</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id (自增)&#x27;</span>,</span><br><span class="line">    `word`        <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;单词&#x27;</span>,</span><br><span class="line">    `description` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;介绍&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci COMMENT <span class="string">&#x27;单词表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>一般，MySQL如下确定使用什么样的字符集和校对。</p><ul><li>如果指定<code>CHARACTER SET</code> 和<code>COLLATE</code> 两者，则使用这些值。</li><li>如果只指定<code>CHARACTER SET</code> ，则使用此字符集及其默认的校对（如<code>SHOW CHARACTER SET</code> 的结果中所示）。</li><li>如果既不指定<code>CHARACTER SET</code> ，也不指定<code>COLLATE</code> ，则使用数据库默认。</li></ul><p>除了能指定字符集和校对的表范围外，MySQL还允许对每个列设置它们，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `words`</span><br><span class="line">(</span><br><span class="line">    `id`          <span class="type">bigint</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id (自增)&#x27;</span>,</span><br><span class="line">    `word`        <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;单词&#x27;</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> latin1 <span class="keyword">COLLATE</span> latin1_general_ci,</span><br><span class="line">    `description` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;介绍&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci COMMENT <span class="string">&#x27;单词表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>校对在对用<code>ORDER BY</code> 子句检索出来的数据排序时起重要的作用。如果你需要用与创建表时不同的校对顺序排序特定的<code>SELECT</code><br>语句，可以在<code>SELECT</code> 语句自身中进行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> words</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> word <span class="keyword">COLLATE</span> latin1_general_cs;</span><br></pre></td></tr></table></figure><p><strong>临时区分大小写</strong></p><p>上面的<code>SELECT</code> 语句演示了在通常不区分大小写的表上进行区分大小写搜索的一种技术。当然，反过来也是可以的。</p><p><strong><code>SELECT</code> 的其他<code>COLLATE</code> 子句</strong></p><p>除了这里看到的在<code>ORDER BY</code> 子句中使用以外，<code>COLLATE</code> 还可以用于<code>GROUP BY</code> 、<code>HAVING</code> 、聚集函数、别名等。</p><p>最后，值得注意的是，如果绝对需要，串可以在字符集之间进行转换。为此，使用<code>Cast()</code> 或<code>Convert()</code> 函数。</p><hr><h2 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USE</span><br><span class="line">mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><h3 id="创建用户账号"><a href="#创建用户账号" class="headerlink" title="创建用户账号"></a><strong>创建用户账号</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span></span><br><span class="line"><span class="keyword">USER</span> bob IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;areyouok&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>CREATE USER</code> 创建一个新用户账号。在创建用户账号时不一定需要口令，不过这个例子用<code>IDENTIFIED BY &#39;areyouok&#39;</code> 给出了一个口令。</p><p><strong>指定散列口令</strong> <code>IDENTIFIED BY</code> 指定的口令为纯文本，MySQL将在保存到<code>user</code><br>表之前对其进行加密。为了作为散列值指定口令，使用<code>IDENTIFIED BY PASSWORD</code> 。</p><p>重新命名一个用户账号，使用<code>RENAME USER</code> 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RENAME</span><br><span class="line"><span class="keyword">USER</span> bob <span class="keyword">TO</span> lucy;</span><br></pre></td></tr></table></figure><p>删除一个用户账号（以及相关的权限），使用<code>DROP USER</code> 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span></span><br><span class="line"><span class="keyword">USER</span> lucy;</span><br></pre></td></tr></table></figure><h3 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a><strong>设置访问权限</strong></h3><p>在创建用户账号后，必须接着分配访问权限。新创建的用户账号没有访问权限。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。</p><p>查看赋予用户账号的权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span></span><br><span class="line">GRANTS <span class="keyword">FOR</span> bob</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT USAGE ON *.* TO `bob`@`%`</span><br></pre></td></tr></table></figure><p><code>USAGE</code> 表示根本没有权限，所以，此结果表示在<em>任意数据库</em> 和<em>任意表</em> 上对<em>任何东西没有权限</em> 。</p><p><strong>用户定义为<code>user@host</code></strong> MySQL的权限用用户名和主机名结合定义。如果不指定主机名，则使用默认的主机名%（授予用户访问权限而不管主机名）。</p><p>为设置权限，使用<code>GRANT</code> 语句。<code>GRANT</code> 要求你至少给出以下信息：</p><ul><li>要授予的权限；</li><li>被授予访问权限的数据库或表；</li><li>用户名。</li></ul><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> mysql_study.<span class="operator">*</span> <span class="keyword">TO</span> bob;</span><br></pre></td></tr></table></figure><p>此<code>GRANT</code> 允许用户在<code>mysql_study.*</code> （<code>mysql_study</code> 数据库的所有表）上使用<code>SELECT</code> 。</p><p>查看权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span></span><br><span class="line">GRANTS <span class="keyword">FOR</span> bob</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT USAGE ON *.* TO `bob`@`%`</span><br><span class="line">GRANT SELECT ON `mysql_study`.* TO `bob`@`%`</span><br></pre></td></tr></table></figure><p>每个<code>GRANT</code> 添加（或更新）用户的一个权限。MySQL读取所有授权，并根据它们确定权限。</p><h3 id="撤销访问权限"><a href="#撤销访问权限" class="headerlink" title="撤销访问权限"></a>撤销访问权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> mysql_study.<span class="operator">*</span> <span class="keyword">TO</span> bob;</span><br></pre></td></tr></table></figure><p>这条<code>REVOKE</code> 语句取消刚赋予用户<code>bob</code> 的<code>SELECT</code> 访问权限。被撤销的访问权限必须存在，否则会出错。</p><p><code>GRANT</code> 和<code>REVOKE</code> 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用<code>GRANT ALL</code> 和<code>REVOKE ALL</code> ；</li><li>整个数据库，使用<code>ON database.*</code> ；</li><li>特定的表，使用<code>ON database.table</code> ；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><p>可以授予或撤销的每个权限。</p><table><thead><tr><th align="center">权 限</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center"><code>ALL</code></td><td align="center">除<code>GRANT OPTION</code> 外的所有权限</td></tr><tr><td align="center"><code>ALTER</code></td><td align="center">使用<code>ALTER TABLE</code></td></tr><tr><td align="center"><code>ALTER ROUTINE</code></td><td align="center">使用<code>ALTER PROCEDURE</code> 和<code>DROP PROCEDURE</code></td></tr><tr><td align="center"><code>CREATE</code></td><td align="center">使用<code>CREATE TABLE</code></td></tr><tr><td align="center"><code>CREATE ROUTINE</code></td><td align="center">使用<code>CREATE PROCEDURE</code></td></tr><tr><td align="center"><code>CREATE TEMPORARY TABLES</code></td><td align="center">使用<code>CREATE TEMPORARY TABLE</code></td></tr><tr><td align="center"><code>CREATE USER</code></td><td align="center">使用<code>CREATE USER</code> 、<code>DROP USER</code> 、<code>RENAME USER</code> 和<code>REVOKE ALL PRIVILEGES</code></td></tr><tr><td align="center"><code>CREATE VIEW</code></td><td align="center">使用<code>CREATE VIEW</code></td></tr><tr><td align="center"><code>DELETE</code></td><td align="center">使用<code>DELETE</code></td></tr><tr><td align="center"><code>DROP</code></td><td align="center">使用<code>DROP TABLE</code></td></tr><tr><td align="center"><code>EXECUTE</code></td><td align="center">使用<code>CALL</code> 和存储过程</td></tr><tr><td align="center"><code>FILE</code></td><td align="center">使用<code>SELECT INTO OUTFILE</code> 和<code>LOAD DATA INFILE</code></td></tr><tr><td align="center"><code>GRANT OPTION</code></td><td align="center">使用<code>GRANT</code> 和<code>REVOKE</code></td></tr><tr><td align="center"><code>INDEX</code></td><td align="center">使用<code>CREATE INDEX</code> 和<code>DROP INDEX</code></td></tr><tr><td align="center"><code>INSERT</code></td><td align="center">使用<code>INSERT</code></td></tr><tr><td align="center"><code>LOCK TABLES</code></td><td align="center">使用<code>LOCK TABLES</code></td></tr><tr><td align="center"><code>PROCESS</code></td><td align="center">使用<code>SHOW FULL PROCESSLIST</code></td></tr><tr><td align="center"><code>RELOAD</code></td><td align="center">使用<code>FLUSH</code></td></tr><tr><td align="center"><code>REPLICATION CLIENT</code></td><td align="center">服务器位置的访问</td></tr><tr><td align="center"><code>REPLICATION SLAVE</code></td><td align="center">由复制从属使用</td></tr><tr><td align="center"><code>SELECT</code></td><td align="center">使用<code>SELECT</code></td></tr><tr><td align="center"><code>SHOW DATABASES</code></td><td align="center">使用<code>SHOW DATABASES</code></td></tr><tr><td align="center"><code>SHOW VIEW</code></td><td align="center">使用<code>SHOW CREATE VIEW</code></td></tr><tr><td align="center"><code>SHUTDOWN</code></td><td align="center">使用<code>mysqladmin shutdown</code> （用来关闭MySQL）</td></tr><tr><td align="center"><code>SUPER</code></td><td align="center">使用<code>CHANGE MASTER</code> 、<code>KILL</code> 、<code>LOGS</code> 、<code>PURGE</code> 、<code>MASTER</code> 和<code>SET GLOBAL</code> 。还允许<code>mysqladmin</code> 调试登录</td></tr><tr><td align="center"><code>UPDATE</code></td><td align="center">使用<code>UPDATE</code></td></tr><tr><td align="center"><code>USAGE</code></td><td align="center">无访问权限</td></tr></tbody></table><p>使用<code>GRANT</code> 和<code>REVOKE</code> ，再结合表中列出的权限，你能对用户可以就你的宝贵数据做什么事情和不能做什么事情具有完全的控制。</p><p><strong>未来的授权</strong> 在使用<code>GRANT</code> 和<code>REVOKE</code> 时，用户账号必须存在，但对所涉及的对象没有这个要求。这允许管理员在创建数据库和表之前设计和实现安全措施。</p><p>这样做的副作用是，当某个数据库或表被删除时（用<code>DROP</code> 语句），相关的访问权限仍然存在。而且，如果将来重新创建该数据库或表，这些权限仍然起作用。</p><p><strong>简化多次授权</strong> 可通过列出各权限并用逗号分隔，将多条<code>GRANT</code> 语句串在一起：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mysql_study.<span class="operator">*</span> <span class="keyword">TO</span> bob;</span><br></pre></td></tr></table></figure><h3 id="更改口令"><a href="#更改口令" class="headerlink" title="更改口令"></a><strong>更改口令</strong></h3><p><code>SET PASSWORD</code> 更新用户口令。新口令必须传递到<code>Password()</code> 函数进行加密。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span></span><br><span class="line">PASSWORD <span class="keyword">FOR</span> bob <span class="operator">=</span> Password(<span class="string">&#x27;aaa&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在不指定用户名时，<code>SET PASSWORD</code> 更新当前登录用户的口令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span></span><br><span class="line">PASSWORD <span class="operator">=</span> Password(<span class="string">&#x27;aaa&#x27;</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h2><h3 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h3><p>解决方案：</p><ul><li>使用命令行实用程序<code>mysqldump</code> 转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。</li><li>可用命令行实用程序<code>mysqlhotcopy</code> 从一个数据库复制所有数据（并非所有数据库引擎都支持这个实用程序）。</li><li>可以使用MySQL的<code>BACKUP TABLE</code> 或<code>SELECT INTO OUTFILE</code><br>转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据可以用<code>RESTORE TABLE</code><br>来复原。</li></ul><p><strong>首先刷新未写数据</strong> 为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用<code>FLUSH TABLES</code> 语句。</p><h3 id="进行数据库维护"><a href="#进行数据库维护" class="headerlink" title="进行数据库维护"></a>进行数据库维护</h3><p>MySQL提供了一系列的语句，可以（应该）用来保证数据库正确和正常运行。</p><p>检查表键是否正确：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE</span><br><span class="line"><span class="keyword">TABLE</span> goods;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Table               Op      Msg_type  Msg_text</span><br><span class="line">mysql_study.goods	analyze	status	  OK</span><br></pre></td></tr></table></figure><p><code>CHECK TABLE</code> 用来针对许多问题对表进行检查。</p><p>在<code>MyISAM</code> 表上还对索引进行检查。<code>CHECK TABLE</code> 支持一系列的用于<code>MyISAM</code> 表的方式。<code>CHANGED</code><br>检查自最后一次检查以来改动过的表。<code>EXTENDED</code> 执行最彻底的检查，<code>FAST</code> 只检查未正常关闭的表，<code>MEDIUM</code><br>检查所有被删除的链接并进行键检验，<code>QUICK</code> 只进行快速扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHECK</span> <span class="keyword">TABLE</span> goods;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Table               Op      Msg_type  Msg_text</span><br><span class="line">mysql_study.goods	check	status	  OK</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果<code>MyISAM</code> 表访问产生不正确和不一致的结果，可能需要用<code>REPAIR TABLE</code>来修复相应的表。这条语句不应该经常使用，如果需要经常使用，可能会有更大的问题要解决。</li><li>如果从一个表中删除大量数据，应该使用<code>OPTIMIZE TABLE</code> 来收回所用的空间，从而优化表的性能。</li></ul><h3 id="诊断启动问题"><a href="#诊断启动问题" class="headerlink" title="诊断启动问题"></a>诊断启动问题</h3><p>服务器启动问题通常在对MySQL配置或服务器本身进行更改时出现。MySQL在这个问题发生时报告错误，但由于多数MySQL服务器是作为系统进程或服务自动启动的，这些消息可能看不到。</p><p>在排除系统启动问题时，首先应该尽量用手动启动服务器。MySQL服务器自身通过在命令行上执行<code>mysqld</code><br>启动。下面是几个重要的<code>mysqld</code> 命令行选项：</p><ul><li><code>--help</code> 显示帮助：一个选项列表；</li><li><code>--safe-mode</code> 装载减去某些最佳配置的服务器；</li><li><code>--verbose</code> 显示全文本消息（为获得更详细的帮助消息与<code>--help</code> 联合使用）；</li><li><code>--version</code> 显示版本信息然后退出。</li></ul><h3 id="查看日志文件"><a href="#查看日志文件" class="headerlink" title="查看日志文件"></a>查看日志文件</h3><p>MySQL维护管理员依赖的一系列日志文件。主要的日志文件有以下几种。</p><ul><li>错误日志。它包含启动和关闭问题以及任意关键错误的细节。此日志通常名为<code>hostname.err</code> ，位于<code>data</code><br>目录中。此日志名可用<code>--log-error</code> 命令行选项更改。</li><li>查询日志。它记录所有MySQL活动，在诊断问题时非常有用。此日志文件可能会很快地变得非常大，因此不应该长期使用它。此日志通常名为<code>hostname.log</code><br>，位于<code>data</code> 目录中。此名字可以用<code>--log</code> 命令行选项更改。</li><li>二进制日志。它记录更新过数据（或者可能更新过数据）的所有语句。此日志通常名为<code>hostname-bin</code> ，位于<code>data</code><br>目录内。此名字可以用<code>--log-bin</code> 命令行选项更改。注意，这个日志文件是MySQL 5中添加的，以前的MySQL版本中使用的是更新日志。</li><li>缓慢查询日志。顾名思义，此日志记录执行缓慢的任何查询。这个日志在确定数据库何处需要优化很有用。此日志通常名为<code>hostname-slow.log</code><br>，位于<code>data</code> 目录中。此名字可以用<code>--log-slow-queries</code> 命令行选项更改。</li></ul><p>在使用日志时，可用<code>FLUSH LOGS</code> 语句来刷新和重新开始所有日志文件。</p><hr><h2 id="改善性能"><a href="#改善性能" class="headerlink" title="改善性能"></a>改善性能</h2><ul><li>MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大小等。（为查看当前设置，可使用<code>SHOW VARIABLES;</code><br>和<code>SHOW STATUS;</code> 。）</li><li>MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多个任务。如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢。如果你遇到显著的性能不良，可使用<code>SHOW PROCESS LIST</code><br>显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用<code>KILL</code> 命令终结某个特定的进程（使用这个命令需要作为管理员登录）。</li><li>总是有不止一种方法编写同一条<code>SELECT</code> 语句。应该试验联结、并、子查询等，找出最佳的方法。</li><li>使用<code>EXPLAIN</code> 语句让MySQL解释它将如何执行一条<code>SELECT</code> 语句。</li><li>一般来说，存储过程执行得比一条一条地执行其中的各条MySQL语句快。</li><li>应该总是使用正确的数据类型。</li><li>决不要检索比需求还要多的数据。换言之，不要用<code>SELECT*</code> （除非你真正需要每个列）。</li><li>有的操作（包括<code>INSERT</code> ）支持一个可选的<code>DELAYED</code> 关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li><li>在导入数据时，应该关闭自动提交。你可能还想删除索引（包括<code>FULLTEXT</code> 索引），然后在导入完成后再重建它们。</li><li>必须索引数据库表以改善数据检索的性能。确定索引什么不是一件微不足道的任务，需要分析使用的<code>SELECT</code> 语句以找出重复的<code>WHERE</code><br>和<code>ORDER BY</code> 子句。如果一个简单的<code>WHERE</code> 子句返回结果所花的时间太长，则可以断定其中使用的列（或几个列）就是需要索引的对象。</li><li>**你的<code>SELECT</code> 语句中有一系列复杂的<code>OR</code> 条件吗？通过使用多条<code>SELECT</code> 语句和连接它们的<code>UNION</code> 语句，你能看到极大的性能改进<br>**。</li><li><strong>索引改善数据检索的性能，但损害数据插入、删除和更新的性能</strong>。如果你有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们。（索引可根据需要添加和删除。）</li><li><code>LIKE</code> 很慢。一般来说，最好是使用<code>FULLTEXT</code> 而不是<code>LIKE</code> 。</li><li>数据库是不断变化的实体。一组优化良好的表一会儿后可能就面目全非了。由于表的使用和内容的更改，理想的优化和配置也会改变。</li><li>最重要的规则就是，每条规则在某些条件下都会被打破。</li></ul><hr><h2 id="My-SQL-数据类型"><a href="#My-SQL-数据类型" class="headerlink" title="My SQL 数据类型"></a>My SQL 数据类型</h2><p>数据类型用于以下目的。</p><ul><li>数据类型允许限制可存储在列中的数据。例如，数值数据类型列只能接受数值。</li><li>数据类型允许在内部更有效地存储数据。可以用一种比文本串更简洁的格式存储数值和日期时间值。</li><li>数据类型允许变换排序顺序。如果所有数据都作为串处理，则1位于10之前，而10又位于2之前（串以字典顺序排序，从左边开始比较，一次一个字符）。作为数值数据类型，数值才能正确排序。</li></ul><p>在设计表时，应该特别重视所用的数据类型。使用错误的数据类型可能会严重地影响应用程序的功能和性能。更改包含数据的列不是一件小事（而且这样做可能会导致数据丢失）。</p><h3 id="串数据类型"><a href="#串数据类型" class="headerlink" title="串数据类型"></a><strong>串数据类型</strong></h3><p>最常用的数据类型是串数据类型。它们存储串，如名字、地址、电话号码、邮政编码等。有两种基本的串类型，分别为定长串和变长串（参见表D-1）。</p><p>定长串接受长度固定的字符串，其长度是在创建表时指定的。定长列不允许多于指定的字符数目。它们分配的存储空间与指定的一样多。<code>CHAR</code><br>属于定长串类型。</p><p>变长串存储可变长度的文本。有些变长数据类型具有最大的定长，而有些则是完全变长的。不管是哪种，只有指定的数据得到保存（额外的数据不保存）<code>TEXT</code><br>属于变长串类型。</p><p>既然变长数据类型这样灵活，为什么还要使用定长数据类型？回答是因为性能。MySQL处理定长列远比处理变长列快得多。此外，MySQL不允许对变长列（或一个列的可变部分）进行索引。这也会极大地影响性能。</p><p><strong>串数据类型</strong></p><table><thead><tr><th align="center">数据类型</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center"><code>CHAR</code></td><td align="center">1～255个字符的定长串。它的长度必须在创建时指定，否则MySQL假定为<code>CHAR(1)</code></td></tr><tr><td align="center"><code>ENUM</code></td><td align="center">接受最多64 K个串组成的一个预定义集合的某个串</td></tr><tr><td align="center"><code>LONGTEXT</code></td><td align="center">与<code>TEXT</code> 相同，但最大长度为4 GB</td></tr><tr><td align="center"><code>MEDIUMTEXT</code></td><td align="center">与<code>TEXT</code> 相同，但最大长度为16 K</td></tr><tr><td align="center"><code>SET</code></td><td align="center">接受最多64个串组成的一个预定义集合的零个或多个串</td></tr><tr><td align="center"><code>TEXT</code></td><td align="center">最大长度为64 K的变长文本</td></tr><tr><td align="center"><code>TINYTEXT</code></td><td align="center">与<code>TEXT</code> 相同，但最大长度为255字节</td></tr><tr><td align="center"><code>VARCHAR</code></td><td align="center">长度可变， 最多不超过255 字节。如果在创建时指定为<code>VARCHAR(n)</code> ，则可存储<code>0</code>到<code>n</code> 个字符的变长串（其中<code>n</code> ≤255）</td></tr></tbody></table><p><strong>使用引号</strong> 不管使用何种形式的串数据类型，串值都必须括在引号内（通常单引号更好）。</p><p><strong>当数值不是数值时</strong><br>你可能会认为电话号码和邮政编码应该存储在数值字段中（数值字段只存储数值数据），但是，这样做却是不可取的。如果在数值字段中存储邮政编码01234，则保存的将是数值1234，实际上丢失了一位数字。需要遵守的基本规则是：如果数值是计算（求和、平均等）中使用的数值，则应该存储在数值数据类型列中。如果作为字符串（可能只包含数字）使用，则应该保存在串数据类型列中。</p><h3 id="数值数据类型"><a href="#数值数据类型" class="headerlink" title="数值数据类型"></a><strong>数值数据类型</strong></h3><p>数值数据类型存储数值。MySQL支持多种数值数据类型，每种存储的数值具有不同的取值范围。显然，支持的取值范围越大，所需存储空间越多。此外，有的数值数据类型支持使用十进制小数点（和小数），而有的则只支持整数。</p><p><strong>有符号或无符号</strong> 所有数值数据类型（除<code>BIT</code> 和<code>BOOLEAN</code><br>外）都可以有符号或无符号。有符号数值列可以存储正或负的数值，无符号数值列只能存储正数。默认情况为有符号，但如果你知道自己不需要存储负值，可以使用<code>UNSIGNED</code><br>关键字，这样做将允许你存储两倍大小的值。</p><p><strong>数值数据类型</strong></p><table><thead><tr><th align="center">数据类型</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center"><code>BIT</code></td><td align="center">位字段，1～64位。（在MySQL 5之前，<code>BIT</code> 在功能上等价于<code>TINYINT</code></td></tr><tr><td align="center"><code>BIGINT</code></td><td align="center">整数值，支持−9223372036854775808～9223372036854775807（如果是<code>UNSIGNED</code> ，为0～18446744073709551615）的数</td></tr><tr><td align="center"><code>BOOLEAN</code> （或<code>BOOL</code> ）</td><td align="center">布尔标志，或者为0或者为1，主要用于开&#x2F;关（on&#x2F;off）标志</td></tr><tr><td align="center"><code>DECIMAL</code> （或<code>DEC</code> ）</td><td align="center">精度可变的浮点值</td></tr><tr><td align="center"><code>DOUBLE</code></td><td align="center">双精度浮点值</td></tr><tr><td align="center"><code>FLOAT</code></td><td align="center">单精度浮点值</td></tr><tr><td align="center"><code>INT</code> （或<code>INTEGER</code> ）</td><td align="center">整数值，支持−2147483648～2147483647（如果是<code>UNSIGNED</code> ，为0～4294967295）的数</td></tr><tr><td align="center"><code>MEDIUMINT</code></td><td align="center">整数值，支持−8388608～8388607（如果是<code>UNSIGNED</code> ，为0～16777215）的数</td></tr><tr><td align="center"><code>REAL</code></td><td align="center">4字节的浮点值</td></tr><tr><td align="center"><code>SMALLINT</code></td><td align="center">整数值，支持−32768～32767（如果是<code>UNSIGNED</code> ，为0～65535）的数</td></tr><tr><td align="center"><code>TINYINT</code></td><td align="center">整数值，支持−128～127（如果为<code>UNSIGNED</code> ，为0～255）的数</td></tr></tbody></table><p><strong>不使用引号</strong> 与串不一样，数值不应该括在引号内。</p><p><strong>存储货币数据类型</strong> MySQL中没有专门存储货币的数据类型，一般情况下使用<code>DECIMAL(8,2)</code>。</p><h3 id="日期和时间数据类型"><a href="#日期和时间数据类型" class="headerlink" title="日期和时间数据类型"></a><strong>日期和时间数据类型</strong></h3><table><thead><tr><th align="center">数据类型</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center"><code>DATE</code></td><td align="center">表示<code>1000-01-01～9999-12-31</code> 的日期，格式为<code>YYYY-MM-DD</code></td></tr><tr><td align="center"><code>DATETIME</code></td><td align="center"><code>DATE</code> 和<code>TIME</code> 的组合</td></tr><tr><td align="center"><code>TIMESTAMP</code></td><td align="center">功能和<code>DATETIME</code> 相同（但范围较小）</td></tr><tr><td align="center"><code>TIME</code></td><td align="center">格式为<code>HH:MM:SS</code></td></tr><tr><td align="center"><code>YEAR</code></td><td align="center">用2位数字表示，范围是70（1970年）～69（2069年），用4位数字表示，范围是1901年～2155年</td></tr></tbody></table><h3 id="二进制数据类型"><a href="#二进制数据类型" class="headerlink" title="二进制数据类型"></a>二进制数据类型</h3><p>二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、多媒体、字处理文档等。</p><table><thead><tr><th align="center">数据类型</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center"><code>BLOB</code></td><td align="center">Blob最大长度为64 KB</td></tr><tr><td align="center"><code>MEDIUMBLOB</code></td><td align="center">Blob最大长度为16 MB</td></tr><tr><td align="center"><code>LONGBLOB</code></td><td align="center">Blob最大长度为4 GB</td></tr><tr><td align="center"><code>TINYBLOB</code></td><td align="center">Blob最大长度为255字节</td></tr></tbody></table><hr><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul><li>my.ini</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure><ul><li>my.cnf</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port=3306</span><br><span class="line">basedir= /home/mysql/</span><br><span class="line">datadir= /home/mysql/data</span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line">socket= /home/mysql/mysql.sock</span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为utf8mb4</span></span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line">collation-server=utf8mb4_0900_ai_ci</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">socket= /home/mysql/mysql.sock</span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8mb4</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://iluis.cn">Luis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://iluis.cn/c24675b4.html">https://iluis.cn/c24675b4.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://iluis.cn" target="_blank">LuisのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL8/">MySQL8</a></div><div class="post_share"><div class="social-share" data-image="/img/luis/t2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/aefb5c52.html" title="Junit5、Mockito3"><img class="cover" src="/img/luis/bg4.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Junit5、Mockito3</div></div></a></div><div class="next-post pull-right"><a href="/14dc86cd.html" title="Effective-Java"><img class="cover" src="/img/luis/t2.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Effective-Java</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/7a3baa07.html" title="MySQL 基础篇"><img class="cover" src="/img/luis/t7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-15</div><div class="title">MySQL 基础篇</div></div></a></div><div><a href="/a2aedf2f.html" title="MySQL 性能优化"><img class="cover" src="/img/luis/bg1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-17</div><div class="title">MySQL 性能优化</div></div></a></div><div><a href="/58b301d4.html" title="MySQL 进阶篇"><img class="cover" src="/img/luis/bg2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-16</div><div class="title">MySQL 进阶篇</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/luis/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Luis</div><div class="author-info__description">低头赶路、敬事如仪</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/iluis97"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">微信公众号: dacoder<br> Gitee: https://gitee.com/iluis<br> GitHub: https://github.com/iluis97</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#RDBMS%E4%B8%8E%E9%9D%9ERDBMS"><span class="toc-number">1.</span> <span class="toc-text">RDBMS与非RDBMS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E7%B4%A2"><span class="toc-number">2.</span> <span class="toc-text">检索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2"><span class="toc-number">3.</span> <span class="toc-text">排序检索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E5%92%8C%E6%8E%92%E5%BA%8F%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text">区分大小写和排序顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9C%80%E5%80%BC"><span class="toc-number">3.2.</span> <span class="toc-text">查询最值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ORDER-BY-%E5%AD%90%E5%8F%A5%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.3.</span> <span class="toc-text">ORDER BY 子句的位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">数据过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8WHERE%E5%AD%90%E5%8F%A5"><span class="toc-number">4.1.</span> <span class="toc-text">使用WHERE子句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WHERE-%E5%AD%90%E5%8F%A5%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">4.1.1.</span> <span class="toc-text">WHERE 子句的位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E5%80%BC%E6%A3%80%E6%9F%A5"><span class="toc-number">4.1.2.</span> <span class="toc-text">空值检查</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88WHERE%E5%AD%90%E5%8F%A5"><span class="toc-number">4.2.</span> <span class="toc-text">组合WHERE子句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AND-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.2.1.</span> <span class="toc-text">AND 操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OR-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.2.2.</span> <span class="toc-text">OR 操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8WHERE-%E5%AD%90%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9C%86%E6%8B%AC%E5%8F%B7"><span class="toc-number">4.2.3.</span> <span class="toc-text">在WHERE 子句中使用圆括号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IN%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.3.</span> <span class="toc-text">IN操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8IN-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.3.1.</span> <span class="toc-text">为什么要使用IN 操作符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NOT%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.4.</span> <span class="toc-text">NOT操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="toc-number">5.</span> <span class="toc-text">用通配符进行过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LIKE%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.1.</span> <span class="toc-text">LIKE操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BE%E5%88%86%E5%8F%B7%EF%BC%88-%EF%BC%89%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">5.1.1.</span> <span class="toc-text">百分号（% ）通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E5%88%92%E7%BA%BF%EF%BC%88-%EF%BC%89%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">5.1.2.</span> <span class="toc-text">下划线（_ ）通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="toc-number">5.1.3.</span> <span class="toc-text">使用通配符的技巧</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2"><span class="toc-number">6.</span> <span class="toc-text">用正则表达式进行搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D"><span class="toc-number">6.1.</span> <span class="toc-text">基本字符匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8COR-%E5%8C%B9%E9%85%8D"><span class="toc-number">6.2.</span> <span class="toc-text">进行OR 匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B9%8B%E4%B8%80"><span class="toc-number">6.3.</span> <span class="toc-text">匹配几个字符之一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E8%8C%83%E5%9B%B4"><span class="toc-number">6.4.</span> <span class="toc-text">匹配范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="toc-number">6.5.</span> <span class="toc-text">匹配特殊字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E7%B1%BB"><span class="toc-number">6.6.</span> <span class="toc-text">匹配字符类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.7.</span> <span class="toc-text">匹配多个实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E7%AC%A6"><span class="toc-number">6.8.</span> <span class="toc-text">定位符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5"><span class="toc-number">7.</span> <span class="toc-text">创建计算字段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5%E5%AD%97%E6%AE%B5"><span class="toc-number">7.1.</span> <span class="toc-text">拼接字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%A9%BA%E6%A0%BC"><span class="toc-number">7.2.</span> <span class="toc-text">删除空格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%88%AB%E5%90%8D"><span class="toc-number">7.3.</span> <span class="toc-text">使用别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%AE%97%E6%9C%AF%E8%AE%A1%E7%AE%97"><span class="toc-number">7.4.</span> <span class="toc-text">执行算术计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.</span> <span class="toc-text">使用数据处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.1.</span> <span class="toc-text">文本处理函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.2.</span> <span class="toc-text">日期和时间处理函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.3.</span> <span class="toc-text">数值处理函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">8.</span> <span class="toc-text">汇总数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.</span> <span class="toc-text">聚集函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E4%B8%8D%E5%90%8C%E5%80%BC"><span class="toc-number">8.2.</span> <span class="toc-text">聚集不同值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text">组合聚集函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE"><span class="toc-number">9.</span> <span class="toc-text">分组数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E7%BB%84"><span class="toc-number">9.1.</span> <span class="toc-text">创建分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%88%86%E7%BB%84"><span class="toc-number">9.2.</span> <span class="toc-text">过滤分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">9.3.</span> <span class="toc-text">分组和排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SELECT%E5%AD%90%E5%8F%A5%E9%A1%BA%E5%BA%8F"><span class="toc-number">9.4.</span> <span class="toc-text">SELECT子句顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">10.</span> <span class="toc-text">使用子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">10.1.</span> <span class="toc-text">作为计算字段使用子查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E7%BB%93%E8%A1%A8"><span class="toc-number">11.</span> <span class="toc-text">联结表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%81%94%E7%BB%93"><span class="toc-number">11.1.</span> <span class="toc-text">创建联结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WHERE-%E5%AD%90%E5%8F%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">11.1.1.</span> <span class="toc-text">WHERE 子句的重要性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF%EF%BC%88cartesianproduct%EF%BC%89"><span class="toc-number">11.1.2.</span> <span class="toc-text">笛卡儿积（cartesianproduct）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E8%81%94%E7%BB%93"><span class="toc-number">11.2.</span> <span class="toc-text">内部联结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E7%BB%93%E5%A4%9A%E4%B8%AA%E8%A1%A8"><span class="toc-number">11.3.</span> <span class="toc-text">联结多个表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93"><span class="toc-number">12.</span> <span class="toc-text">创建高级联结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A1%A8%E5%88%AB%E5%90%8D"><span class="toc-number">12.1.</span> <span class="toc-text">使用表别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%81%94%E7%BB%93"><span class="toc-number">12.2.</span> <span class="toc-text">使用不同类型的联结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E8%81%94%E7%BB%93"><span class="toc-number">12.2.1.</span> <span class="toc-text">自联结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E8%81%94%E7%BB%93"><span class="toc-number">12.2.2.</span> <span class="toc-text">自然联结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E8%81%94%E7%BB%93"><span class="toc-number">12.2.3.</span> <span class="toc-text">外部联结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">13.</span> <span class="toc-text">组合查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">13.1.</span> <span class="toc-text">创建组合查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8UNION"><span class="toc-number">13.1.1.</span> <span class="toc-text">使用UNION</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E6%8E%92%E5%BA%8F"><span class="toc-number">13.2.</span> <span class="toc-text">对组合查询结果排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="toc-number">14.</span> <span class="toc-text">全文本搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E9%9D%9E%E6%89%80%E6%9C%89%E5%BC%95%E6%93%8E%E9%83%BD%E6%94%AF%E6%8C%81%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="toc-number">14.1.</span> <span class="toc-text">并非所有引擎都支持全文本搜索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">15.</span> <span class="toc-text">插入数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%AE%8C%E6%95%B4%E7%9A%84%E8%A1%8C"><span class="toc-number">15.1.</span> <span class="toc-text">插入完整的行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%A4%9A%E4%B8%AA%E8%A1%8C"><span class="toc-number">15.2.</span> <span class="toc-text">插入多个行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%A3%80%E7%B4%A2%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">15.3.</span> <span class="toc-text">插入检索出的数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#INSERT-SELECT-%E4%B8%AD%E7%9A%84%E5%88%97%E5%90%8D"><span class="toc-number">15.3.1.</span> <span class="toc-text">INSERT SELECT 中的列名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">16.</span> <span class="toc-text">更新和删除数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="toc-number">16.1.</span> <span class="toc-text">更新数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">16.2.</span> <span class="toc-text">删除数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8"><span class="toc-number">17.</span> <span class="toc-text">创建和操纵表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="toc-number">17.1.</span> <span class="toc-text">创建表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8NULL-%E5%80%BC"><span class="toc-number">17.1.1.</span> <span class="toc-text">使用NULL 值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE"><span class="toc-number">17.1.2.</span> <span class="toc-text">主键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8AUTO-INCREMENT"><span class="toc-number">17.1.3.</span> <span class="toc-text">使用AUTO_INCREMENT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">17.1.4.</span> <span class="toc-text">指定默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E6%93%8E%E7%B1%BB%E5%9E%8B"><span class="toc-number">17.1.5.</span> <span class="toc-text">引擎类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%A1%A8"><span class="toc-number">17.2.</span> <span class="toc-text">更新表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A1%A8"><span class="toc-number">17.3.</span> <span class="toc-text">删除表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E8%A1%A8"><span class="toc-number">17.4.</span> <span class="toc-text">重命名表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE"><span class="toc-number">18.</span> <span class="toc-text">使用视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">18.1.</span> <span class="toc-text">常见的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">18.2.</span> <span class="toc-text">性能问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E8%A7%84%E5%88%99%E5%92%8C%E9%99%90%E5%88%B6"><span class="toc-number">18.3.</span> <span class="toc-text">视图的规则和限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE-1"><span class="toc-number">18.4.</span> <span class="toc-text">使用视图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">18.4.1.</span> <span class="toc-text">视图的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%A7%86%E5%9B%BE%E7%AE%80%E5%8C%96%E5%A4%8D%E6%9D%82%E7%9A%84%E8%81%94%E7%BB%93"><span class="toc-number">18.4.2.</span> <span class="toc-text">利用视图简化复杂的联结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E8%A7%86%E5%9B%BE%E8%BF%87%E6%BB%A4%E4%B8%8D%E6%83%B3%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">18.4.3.</span> <span class="toc-text">用视图过滤不想要的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%E4%B8%8E%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5"><span class="toc-number">18.4.4.</span> <span class="toc-text">使用视图与计算字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE"><span class="toc-number">18.5.</span> <span class="toc-text">更新视图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">19.</span> <span class="toc-text">使用存储过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87"><span class="toc-number">20.</span> <span class="toc-text">使用游标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">21.</span> <span class="toc-text">使用触发器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">22.</span> <span class="toc-text">管理事务处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E8%AF%AD%E5%8F%A5%E5%8F%AF%E4%BB%A5%E5%9B%9E%E9%80%80"><span class="toc-number">22.1.</span> <span class="toc-text">哪些语句可以回退</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8COMMIT"><span class="toc-number">22.2.</span> <span class="toc-text">使用COMMIT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%9D%E7%95%99%E7%82%B9"><span class="toc-number">22.3.</span> <span class="toc-text">使用保留点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E7%9A%84%E6%8F%90%E4%BA%A4%E8%A1%8C%E4%B8%BA"><span class="toc-number">22.4.</span> <span class="toc-text">更改默认的提交行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E7%90%83%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96"><span class="toc-number">23.</span> <span class="toc-text">全球化和本地化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%A0%A1%E5%AF%B9%E9%A1%BA%E5%BA%8F"><span class="toc-number">23.1.</span> <span class="toc-text">使用字符集和校对顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86"><span class="toc-number">24.</span> <span class="toc-text">安全管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7"><span class="toc-number">24.1.</span> <span class="toc-text">管理用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E8%B4%A6%E5%8F%B7"><span class="toc-number">24.2.</span> <span class="toc-text">创建用户账号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">24.3.</span> <span class="toc-text">设置访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">24.4.</span> <span class="toc-text">撤销访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%8F%A3%E4%BB%A4"><span class="toc-number">24.5.</span> <span class="toc-text">更改口令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4"><span class="toc-number">25.</span> <span class="toc-text">数据库维护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE"><span class="toc-number">25.1.</span> <span class="toc-text">备份数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4"><span class="toc-number">25.2.</span> <span class="toc-text">进行数据库维护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8A%E6%96%AD%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="toc-number">25.3.</span> <span class="toc-text">诊断启动问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-number">25.4.</span> <span class="toc-text">查看日志文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD"><span class="toc-number">26.</span> <span class="toc-text">改善性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#My-SQL-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">27.</span> <span class="toc-text">My SQL 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">27.1.</span> <span class="toc-text">串数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">27.2.</span> <span class="toc-text">数值数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">27.3.</span> <span class="toc-text">日期和时间数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">27.4.</span> <span class="toc-text">二进制数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">28.</span> <span class="toc-text">配置文件</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/a2aedf2f.html" title="MySQL 性能优化"><img src="/img/luis/bg1.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="MySQL 性能优化"></a><div class="content"><a class="title" href="/a2aedf2f.html" title="MySQL 性能优化">MySQL 性能优化</a><time datetime="2025-05-17T02:21:13.000Z" title="发表于 2025-05-17 10:21:13">2025-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/58b301d4.html" title="MySQL 进阶篇"><img src="/img/luis/bg2.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="MySQL 进阶篇"></a><div class="content"><a class="title" href="/58b301d4.html" title="MySQL 进阶篇">MySQL 进阶篇</a><time datetime="2025-05-16T08:00:13.000Z" title="发表于 2025-05-16 16:00:13">2025-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7a3baa07.html" title="MySQL 基础篇"><img src="/img/luis/t7.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="MySQL 基础篇"></a><div class="content"><a class="title" href="/7a3baa07.html" title="MySQL 基础篇">MySQL 基础篇</a><time datetime="2025-05-15T06:51:13.000Z" title="发表于 2025-05-15 14:51:13">2025-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d5d7710f.html" title="JVM 知识提升"><img src="/img/luis/bg1.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="JVM 知识提升"></a><div class="content"><a class="title" href="/d5d7710f.html" title="JVM 知识提升">JVM 知识提升</a><time datetime="2025-05-10T05:12:02.000Z" title="发表于 2025-05-10 13:12:02">2025-05-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e3f46350.html" title="JVM 知识梳理"><img src="/img/luis/bg2.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="JVM 知识梳理"></a><div class="content"><a class="title" href="/e3f46350.html" title="JVM 知识梳理">JVM 知识梳理</a><time datetime="2025-05-09T05:12:02.000Z" title="发表于 2025-05-09 13:12:02">2025-05-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/luis/t2.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By Luis</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>辽 ICP 备 2020012865 号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" src="/js/jquery.slim.min.js"></script><script defer="defer" data-pjax src="/js/cat.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>